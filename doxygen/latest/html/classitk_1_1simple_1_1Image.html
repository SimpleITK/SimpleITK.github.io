<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Google Tag Manager -->
<script>
  (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push(
  {'gtm.start': new Date().getTime(),event:'gtm.js'}
  );var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-N38XC8T');
</script>
<!-- End Google Tag Manager -->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimpleITK: itk::simple::Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N38XC8T"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe>
</noscript>
<!-- End Google Tag Manager (noscript) -->
<script type="text/javascript" src="build_text.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SimpleITK
   &#160;<span id="projectnumber"></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>itk</b></li><li class="navelem"><a class="el" href="namespaceitk_1_1simple.html">simple</a></li><li class="navelem"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classitk_1_1simple_1_1Image-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">itk::simple::Image Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class for SimpleITK.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for itk::simple::Image:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classitk_1_1simple_1_1Image__coll__graph.svg" width="450" height="330"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class for SimpleITK. </p>
<p>This <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class can represent 2D, 3D, and 4D images. The pixel types may be a scalar, a multi-component vector or a run-length-encoded (RLE) "label". The dimension, pixel type and size is specified at construction.</p>
<p>A fundamental concept of ITK images is that they occupy physical space where the image is defined by an origin, spacing, and direction cosine matrix. The attributes are taken into consideration when doing most operations on an image. A meta-data dictionary is also associated with the image, which may contain additional fields from reading but these attributes are not propagated by image filters.</p>
<p>The SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> provides a single facade interface to several ITK image types. Internally, the SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> maintains a pointer to the ITK image class, and performs reference counting and lazy copying. This means that deep copying of an image including it's buffer is delayed until the image is modified. This removes the need to use pointers to SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class, as copying and returning by value do not unnecessarily duplicate the data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Image.html">itk::Image</a> <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1VectorImage.html">itk::VectorImage</a> <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1LabelMap.html">itk::LabelMap</a> <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1ImageBase.html">itk::ImageBase</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="BufferImportExport_8cxx-example.html#_a5">BufferImportExport.cxx</a>, <a class="el" href="CppCMake_2Source_2sitk_example_8cxx-example.html#_a0">CppCMake/Source/sitk_example.cxx</a>, <a class="el" href="CppInPlace_2CppInPlace_8cxx-example.html#_a0">CppInPlace/CppInPlace.cxx</a>, <a class="el" href="DemonsRegistration1_2DemonsRegistration1_8cxx-example.html#_a3">DemonsRegistration1/DemonsRegistration1.cxx</a>, <a class="el" href="DemonsRegistration2_2DemonsRegistration2_8cs-example.html#_a5">DemonsRegistration2/DemonsRegistration2.cs</a>, <a class="el" href="DemonsRegistration2_2DemonsRegistration2_8cxx-example.html#_a3">DemonsRegistration2/DemonsRegistration2.cxx</a>, <a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cs-example.html#_a1">DicomSeriesFromArray/DicomSeriesFromArray.cs</a>, <a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cxx-example.html#_a1">DicomSeriesFromArray/DicomSeriesFromArray.cxx</a>, <a class="el" href="DicomSeriesReader_2DicomSeriesReader_8cs-example.html#_a3">DicomSeriesReader/DicomSeriesReader.cs</a>, <a class="el" href="DicomSeriesReader_2DicomSeriesReader_8cxx-example.html#_a3">DicomSeriesReader/DicomSeriesReader.cxx</a>, <a class="el" href="FastMarchingSegmentation_2FastMarchingSegmentation_8cxx-example.html#_a0">FastMarchingSegmentation/FastMarchingSegmentation.cxx</a>, <a class="el" href="FilterProgressReporting_2FilterProgressReporting_8cs-example.html#_a6">FilterProgressReporting/FilterProgressReporting.cs</a>, <a class="el" href="FilterProgressReporting_2FilterProgressReporting_8cxx-example.html#_a5">FilterProgressReporting/FilterProgressReporting.cxx</a>, <a class="el" href="HelloWorld_2HelloWorld_8cs-example.html#_a0">HelloWorld/HelloWorld.cs</a>, <a class="el" href="HelloWorld_2HelloWorld_8cxx-example.html#_a0">HelloWorld/HelloWorld.cxx</a>, <a class="el" href="ITKIntegration_2ITKIntegration_8cxx-example.html#_a2">ITKIntegration/ITKIntegration.cxx</a>, <a class="el" href="ImageIOSelection_2ImageIOSelection_8cs-example.html#_a5">ImageIOSelection/ImageIOSelection.cs</a>, <a class="el" href="ImageIOSelection_2ImageIOSelection_8cxx-example.html#_a5">ImageIOSelection/ImageIOSelection.cxx</a>, <a class="el" href="ImageRegistrationMethod1_2ImageRegistrationMethod1_8cs-example.html#_a8">ImageRegistrationMethod1/ImageRegistrationMethod1.cs</a>, <a class="el" href="ImageRegistrationMethod1_2ImageRegistrationMethod1_8cxx-example.html#_a3">ImageRegistrationMethod1/ImageRegistrationMethod1.cxx</a>, <a class="el" href="ImageRegistrationMethod2_2ImageRegistrationMethod2_8cs-example.html#_a8">ImageRegistrationMethod2/ImageRegistrationMethod2.cs</a>, <a class="el" href="ImageRegistrationMethod2_2ImageRegistrationMethod2_8cxx-example.html#_a3">ImageRegistrationMethod2/ImageRegistrationMethod2.cxx</a>, <a class="el" href="ImageRegistrationMethodBSpline1_2ImageRegistrationMethodBSpline1_8cxx-example.html#_a3">ImageRegistrationMethodBSpline1/ImageRegistrationMethodBSpline1.cxx</a>, <a class="el" href="ImageRegistrationMethodBSpline3_2ImageRegistrationMethodBSpline3_8cxx-example.html#_a4">ImageRegistrationMethodBSpline3/ImageRegistrationMethodBSpline3.cxx</a>, <a class="el" href="ImageRegistrationMethodDisplacement1_2ImageRegistrationMethodDisplacement1_8cxx-example.html#_a3">ImageRegistrationMethodDisplacement1/ImageRegistrationMethodDisplacement1.cxx</a>, <a class="el" href="N4BiasFieldCorrection_2N4BiasFieldCorrection_8cs-example.html#_a0">N4BiasFieldCorrection/N4BiasFieldCorrection.cs</a>, <a class="el" href="N4BiasFieldCorrection_2N4BiasFieldCorrection_8cxx-example.html#_a0">N4BiasFieldCorrection/N4BiasFieldCorrection.cxx</a>, <a class="el" href="Segmentation_2ConnectedThresholdImageFilter_8cxx-example.html#_a2">Segmentation/ConnectedThresholdImageFilter.cxx</a>, <a class="el" href="Segmentation_2NeighborhoodConnectedImageFilter_8cxx-example.html#_a2">Segmentation/NeighborhoodConnectedImageFilter.cxx</a>, <a class="el" href="SimpleGaussian_2SimpleGaussian_8cs-example.html#_a2">SimpleGaussian/SimpleGaussian.cs</a>, <a class="el" href="SimpleGaussian_2SimpleGaussian_8cxx-example.html#_a2">SimpleGaussian/SimpleGaussian.cxx</a>, <a class="el" href="SimpleGaussianFunctional_8cxx-example.html#_a0">SimpleGaussianFunctional.cxx</a>, <a class="el" href="SimpleIO_2SimpleIO_8cs-example.html#_a3">SimpleIO/SimpleIO.cs</a>, <a class="el" href="SimpleIO_2SimpleIO_8cxx-example.html#_a3">SimpleIO/SimpleIO.cxx</a>, and <a class="el" href="SliceBySliceDecorator_2SliceBySliceDecorator_8cxx-example.html#_a0">SliceBySliceDecorator/SliceBySliceDecorator.cxx</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00076">76</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5f3a8beb0170782f77853b044ddd02a4" id="r_a5f3a8beb0170782f77853b044ddd02a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f3a8beb0170782f77853b044ddd02a4">Self</a> = <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a></td></tr>
<tr class="separator:a5f3a8beb0170782f77853b044ddd02a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa8a4757400c414e809d1767ee616bd0" id="r_afa8a4757400c414e809d1767ee616bd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8a4757400c414e809d1767ee616bd0">CopyInformation</a> (const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;srcImage)</td></tr>
<tr class="memdesc:afa8a4757400c414e809d1767ee616bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy common meta-data from an image to this one.  <br /></td></tr>
<tr class="separator:afa8a4757400c414e809d1767ee616bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c224f1f5173836258dbb983341a2f9" id="r_af5c224f1f5173836258dbb983341a2f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5c224f1f5173836258dbb983341a2f9">EraseMetaData</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:af5c224f1f5173836258dbb983341a2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry from the meta-data dictionary.  <br /></td></tr>
<tr class="separator:af5c224f1f5173836258dbb983341a2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393912859bda381a8b7b0ec79cfce4a1" id="r_a393912859bda381a8b7b0ec79cfce4a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a393912859bda381a8b7b0ec79cfce4a1">EvaluateAtContinuousIndex</a> (const std::vector&lt; double &gt; &amp;index, <a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5">InterpolatorEnum</a> interp=<a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5ab1d3c20fe43968ed72c71ae2a59d860a">sitkLinear</a>) const</td></tr>
<tr class="memdesc:a393912859bda381a8b7b0ec79cfce4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate pixel value at a continuous index.  <br /></td></tr>
<tr class="separator:a393912859bda381a8b7b0ec79cfce4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f96579d0f3da2d1a3b48d4e1037fbc" id="r_aa2f96579d0f3da2d1a3b48d4e1037fbc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2f96579d0f3da2d1a3b48d4e1037fbc">EvaluateAtPhysicalPoint</a> (const std::vector&lt; double &gt; &amp;point, <a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5">InterpolatorEnum</a> interp=<a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5ab1d3c20fe43968ed72c71ae2a59d860a">sitkLinear</a>) const</td></tr>
<tr class="separator:aa2f96579d0f3da2d1a3b48d4e1037fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9d6f84e457f7f6e59665c26a02cd4e" id="r_a0e9d6f84e457f7f6e59665c26a02cd4e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e9d6f84e457f7f6e59665c26a02cd4e">GetDepth</a> () const</td></tr>
<tr class="separator:a0e9d6f84e457f7f6e59665c26a02cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43163c72ca1a49abf615b3dc71e01a36" id="r_a43163c72ca1a49abf615b3dc71e01a36"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension</a> () const</td></tr>
<tr class="separator:a43163c72ca1a49abf615b3dc71e01a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a9572d84ae73623652bdc1ecb7cf2d" id="r_a88a9572d84ae73623652bdc1ecb7cf2d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a9572d84ae73623652bdc1ecb7cf2d">GetHeight</a> () const</td></tr>
<tr class="separator:a88a9572d84ae73623652bdc1ecb7cf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43df17945f303feb16b4accf1b684515" id="r_a43df17945f303feb16b4accf1b684515"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43df17945f303feb16b4accf1b684515">GetMetaData</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a43df17945f303feb16b4accf1b684515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a meta-data dictionary entry as a string.  <br /></td></tr>
<tr class="separator:a43df17945f303feb16b4accf1b684515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf9bbdb75a90784da8012286a8692eb" id="r_a4cf9bbdb75a90784da8012286a8692eb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cf9bbdb75a90784da8012286a8692eb">GetMetaDataKeys</a> () const</td></tr>
<tr class="memdesc:a4cf9bbdb75a90784da8012286a8692eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector of keys in from the meta-data dictionary  <br /></td></tr>
<tr class="separator:a4cf9bbdb75a90784da8012286a8692eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b4188222fc781607ab26c69fc5423" id="r_abb8b4188222fc781607ab26c69fc5423"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb8b4188222fc781607ab26c69fc5423">GetNumberOfComponentsPerPixel</a> () const</td></tr>
<tr class="memdesc:abb8b4188222fc781607ab26c69fc5423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of components for each pixel.  <br /></td></tr>
<tr class="separator:abb8b4188222fc781607ab26c69fc5423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584912065b5cc03923319b15bd9fc16e" id="r_a584912065b5cc03923319b15bd9fc16e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a584912065b5cc03923319b15bd9fc16e">GetNumberOfPixels</a> () const</td></tr>
<tr class="memdesc:a584912065b5cc03923319b15bd9fc16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of pixels in the image.  <br /></td></tr>
<tr class="separator:a584912065b5cc03923319b15bd9fc16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780923bec6a71b14be35d81069f343f6" id="r_a780923bec6a71b14be35d81069f343f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a780923bec6a71b14be35d81069f343f6">GetPixelID</a> () const</td></tr>
<tr class="separator:a780923bec6a71b14be35d81069f343f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad195963d0b257560819b833b9cfe18d6" id="r_ad195963d0b257560819b833b9cfe18d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad195963d0b257560819b833b9cfe18d6">GetPixelIDTypeAsString</a> () const</td></tr>
<tr class="separator:ad195963d0b257560819b833b9cfe18d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c27e845c3327ae8cf133db1750fd18b" id="r_a3c27e845c3327ae8cf133db1750fd18b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceitk_1_1simple.html#aaf027344ec3011c3ac6fcfd77271bb75">PixelIDValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">GetPixelIDValue</a> () const</td></tr>
<tr class="separator:a3c27e845c3327ae8cf133db1750fd18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade45738b2c906a51f23532aa972f6169" id="r_ade45738b2c906a51f23532aa972f6169"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade45738b2c906a51f23532aa972f6169">GetSize</a> () const</td></tr>
<tr class="separator:ade45738b2c906a51f23532aa972f6169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4705e6e3ad0dcec4a8230462af81c19" id="r_af4705e6e3ad0dcec4a8230462af81c19"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4705e6e3ad0dcec4a8230462af81c19">GetSizeOfPixelComponent</a> () const</td></tr>
<tr class="memdesc:af4705e6e3ad0dcec4a8230462af81c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes per component of a pixel.  <br /></td></tr>
<tr class="separator:af4705e6e3ad0dcec4a8230462af81c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b9ca4a6cd1a0c77e8c5c713e447b3a" id="r_af7b9ca4a6cd1a0c77e8c5c713e447b3a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b9ca4a6cd1a0c77e8c5c713e447b3a">GetWidth</a> () const</td></tr>
<tr class="separator:af7b9ca4a6cd1a0c77e8c5c713e447b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b869a842f2e7aeb75fbd0a84046cca" id="r_a38b869a842f2e7aeb75fbd0a84046cca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38b869a842f2e7aeb75fbd0a84046cca">HasMetaDataKey</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a38b869a842f2e7aeb75fbd0a84046cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the meta-data dictionary for the existence of a key.  <br /></td></tr>
<tr class="separator:a38b869a842f2e7aeb75fbd0a84046cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a8055958ef17e5fd3602e68e28fcc7" id="r_a42a8055958ef17e5fd3602e68e28fcc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image</a> ()</td></tr>
<tr class="memdesc:a42a8055958ef17e5fd3602e68e28fcc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, creates an image of size 0.  <br /></td></tr>
<tr class="separator:a42a8055958ef17e5fd3602e68e28fcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a51dbe990dae1370afe39a65103527" id="r_ae3a51dbe990dae1370afe39a65103527"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a51dbe990dae1370afe39a65103527">Image</a> (const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;img)</td></tr>
<tr class="separator:ae3a51dbe990dae1370afe39a65103527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92e6ec5a7b76f66671d14480906aef0" id="r_af92e6ec5a7b76f66671d14480906aef0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af92e6ec5a7b76f66671d14480906aef0">Image</a> (<a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&amp;img) noexcept</td></tr>
<tr class="memdesc:af92e6ec5a7b76f66671d14480906aef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor and assignment.  <br /></td></tr>
<tr class="separator:af92e6ec5a7b76f66671d14480906aef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69467355f435bc8ec5749402679ce0b1" id="r_a69467355f435bc8ec5749402679ce0b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69467355f435bc8ec5749402679ce0b1">IsCongruentImageGeometry</a> (const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;otherImage, double coordinateTolerance, double directionTolerance) const</td></tr>
<tr class="separator:a69467355f435bc8ec5749402679ce0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5422fe56eb946fc813b85d134a36da13" id="r_a5422fe56eb946fc813b85d134a36da13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5422fe56eb946fc813b85d134a36da13">IsSameImageGeometryAs</a> (const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;otherImage, double=<a class="el" href="#a62caf35a0504c5c761abdf71d4018a89">DefaultImageCoordinateTolerance</a>, double=<a class="el" href="#aa0f5123f49cd495f86349f7e06a49c3d">DefaultImageDirectionTolerance</a>) const</td></tr>
<tr class="separator:a5422fe56eb946fc813b85d134a36da13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5b1f66e3812a286b3e9f4ac8ed976f" id="r_aec5b1f66e3812a286b3e9f4ac8ed976f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec5b1f66e3812a286b3e9f4ac8ed976f">IsUnique</a> () const</td></tr>
<tr class="memdesc:aec5b1f66e3812a286b3e9f4ac8ed976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no other SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> object refers to the same internal data structure.  <br /></td></tr>
<tr class="separator:aec5b1f66e3812a286b3e9f4ac8ed976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5066b75d324db414df1a34c4065d1c9" id="r_ab5066b75d324db414df1a34c4065d1c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5066b75d324db414df1a34c4065d1c9">MakeUnique</a> ()</td></tr>
<tr class="memdesc:ab5066b75d324db414df1a34c4065d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs actually coping if needed to make object unique.  <br /></td></tr>
<tr class="separator:ab5066b75d324db414df1a34c4065d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544257ed6b37d939c081af1c18753b2c" id="r_a544257ed6b37d939c081af1c18753b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a544257ed6b37d939c081af1c18753b2c">operator=</a> (const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;img)</td></tr>
<tr class="separator:a544257ed6b37d939c081af1c18753b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7c186de418cc97050e3ced622cf8c2" id="r_abd7c186de418cc97050e3ced622cf8c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd7c186de418cc97050e3ced622cf8c2">operator=</a> (<a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&amp;img) noexcept</td></tr>
<tr class="separator:abd7c186de418cc97050e3ced622cf8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8edfcd47f578d5e6cd48b76550caf8" id="r_a3f8edfcd47f578d5e6cd48b76550caf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f8edfcd47f578d5e6cd48b76550caf8">ProxyForInPlaceOperation</a> ()</td></tr>
<tr class="memdesc:a3f8edfcd47f578d5e6cd48b76550caf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced method not commonly needed.  <br /></td></tr>
<tr class="separator:a3f8edfcd47f578d5e6cd48b76550caf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1663c39bf013511f30a632a6b4290d83" id="r_a1663c39bf013511f30a632a6b4290d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1663c39bf013511f30a632a6b4290d83">SetMetaData</a> (const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr class="memdesc:a1663c39bf013511f30a632a6b4290d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an entry in the meta-data dictionary.  <br /></td></tr>
<tr class="separator:a1663c39bf013511f30a632a6b4290d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6648c0273680255f7d75e5608fe78f74" id="r_a6648c0273680255f7d75e5608fe78f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6648c0273680255f7d75e5608fe78f74">ToScalarImage</a> (bool inPlace=true)</td></tr>
<tr class="memdesc:a6648c0273680255f7d75e5608fe78f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a image of vector pixel type to a scalar image with N+1 dimensions.  <br /></td></tr>
<tr class="separator:a6648c0273680255f7d75e5608fe78f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c9fa1902dae8f984bda1bdeafa4a3c" id="r_a47c9fa1902dae8f984bda1bdeafa4a3c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47c9fa1902dae8f984bda1bdeafa4a3c">ToString</a> () const</td></tr>
<tr class="separator:a47c9fa1902dae8f984bda1bdeafa4a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ee03fbbfe962cd2b5b39ef9fc4df44" id="r_ad6ee03fbbfe962cd2b5b39ef9fc4df44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6ee03fbbfe962cd2b5b39ef9fc4df44">ToVectorImage</a> (bool inPlace=true)</td></tr>
<tr class="memdesc:ad6ee03fbbfe962cd2b5b39ef9fc4df44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the first dimension to the components for image with vector pixel type.  <br /></td></tr>
<tr class="separator:ad6ee03fbbfe962cd2b5b39ef9fc4df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639da24d8df6d41989447d2ec95cb51d" id="r_a639da24d8df6d41989447d2ec95cb51d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a639da24d8df6d41989447d2ec95cb51d">TransformContinuousIndexToPhysicalPoint</a> (const std::vector&lt; double &gt; &amp;index) const</td></tr>
<tr class="separator:a639da24d8df6d41989447d2ec95cb51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c1a1ecaa5bd379d3132c7e95619aaa" id="r_a87c1a1ecaa5bd379d3132c7e95619aaa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87c1a1ecaa5bd379d3132c7e95619aaa">TransformIndexToPhysicalPoint</a> (const std::vector&lt; int64_t &gt; &amp;index) const</td></tr>
<tr class="separator:a87c1a1ecaa5bd379d3132c7e95619aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aa3f19b31f54ec9fc2846a29428adb" id="r_af2aa3f19b31f54ec9fc2846a29428adb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2aa3f19b31f54ec9fc2846a29428adb">TransformPhysicalPointToContinuousIndex</a> (const std::vector&lt; double &gt; &amp;point) const</td></tr>
<tr class="separator:af2aa3f19b31f54ec9fc2846a29428adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9474e4ded374c8350418fe5329187704" id="r_a9474e4ded374c8350418fe5329187704"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9474e4ded374c8350418fe5329187704">TransformPhysicalPointToIndex</a> (const std::vector&lt; double &gt; &amp;point) const</td></tr>
<tr class="separator:a9474e4ded374c8350418fe5329187704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef33af720d7ce65533fbb10b2b53f51" id="r_adef33af720d7ce65533fbb10b2b53f51"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adef33af720d7ce65533fbb10b2b53f51">~Image</a> ()</td></tr>
<tr class="separator:adef33af720d7ce65533fbb10b2b53f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a14b96e088ce9f8d72f3c71663b376476" id="r_a14b96e088ce9f8d72f3c71663b376476"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14b96e088ce9f8d72f3c71663b376476">Image</a> (unsigned int width, unsigned int height, <a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> valueEnum)</td></tr>
<tr class="memdesc:a14b96e088ce9f8d72f3c71663b376476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified.  <br /></td></tr>
<tr class="separator:a14b96e088ce9f8d72f3c71663b376476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619f5f36459b477581b3d7f0c99d1f9c" id="r_a619f5f36459b477581b3d7f0c99d1f9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619f5f36459b477581b3d7f0c99d1f9c">Image</a> (unsigned int width, unsigned int height, unsigned int depth, <a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> valueEnum)</td></tr>
<tr class="memdesc:a619f5f36459b477581b3d7f0c99d1f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified.  <br /></td></tr>
<tr class="separator:a619f5f36459b477581b3d7f0c99d1f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc77be35235acbc1b67e60e7670194c" id="r_affc77be35235acbc1b67e60e7670194c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affc77be35235acbc1b67e60e7670194c">Image</a> (const std::vector&lt; unsigned int &gt; &amp;size, <a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> valueEnum, unsigned int numberOfComponents=0)</td></tr>
<tr class="memdesc:affc77be35235acbc1b67e60e7670194c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified.  <br /></td></tr>
<tr class="separator:affc77be35235acbc1b67e60e7670194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1b10a5a2f14a9bec516ff47bcba96761" id="r_a1b10a5a2f14a9bec516ff47bcba96761"><td class="memTemplParams" colspan="2">template&lt;typename TImageType&gt; </td></tr>
<tr class="memitem:a1b10a5a2f14a9bec516ff47bcba96761"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b10a5a2f14a9bec516ff47bcba96761">Image</a> (<a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1SmartPointer.html">itk::SmartPointer</a>&lt; TImageType &gt; image)</td></tr>
<tr class="memdesc:a1b10a5a2f14a9bec516ff47bcba96761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> from an pointer to an ITK image.  <br /></td></tr>
<tr class="separator:a1b10a5a2f14a9bec516ff47bcba96761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135e55d13e3baf01d3cd906d40558605" id="r_a135e55d13e3baf01d3cd906d40558605"><td class="memTemplParams" colspan="2">template&lt;typename TImageType&gt; </td></tr>
<tr class="memitem:a135e55d13e3baf01d3cd906d40558605"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a135e55d13e3baf01d3cd906d40558605">Image</a> (TImageType *image)</td></tr>
<tr class="memdesc:a135e55d13e3baf01d3cd906d40558605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> from an pointer to an ITK image.  <br /></td></tr>
<tr class="separator:a135e55d13e3baf01d3cd906d40558605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a600c5cd0fe2345b2d0a2e09997dfa1d6" id="r_a600c5cd0fe2345b2d0a2e09997dfa1d6"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a600c5cd0fe2345b2d0a2e09997dfa1d6">GetITKBase</a> ()</td></tr>
<tr class="separator:a600c5cd0fe2345b2d0a2e09997dfa1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590b6dd151816ef8a4b549e95ed1bf57" id="r_a590b6dd151816ef8a4b549e95ed1bf57"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a590b6dd151816ef8a4b549e95ed1bf57">GetITKBase</a> () const</td></tr>
<tr class="separator:a590b6dd151816ef8a4b549e95ed1bf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a622920d3325ee831eba2ddad89d7eb3d" id="r_a622920d3325ee831eba2ddad89d7eb3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a622920d3325ee831eba2ddad89d7eb3d">GetOrigin</a> () const</td></tr>
<tr class="separator:a622920d3325ee831eba2ddad89d7eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9648b61b714ddd980d3b7b78bf5562ed" id="r_a9648b61b714ddd980d3b7b78bf5562ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9648b61b714ddd980d3b7b78bf5562ed">SetOrigin</a> (const std::vector&lt; double &gt; &amp;origin)</td></tr>
<tr class="separator:a9648b61b714ddd980d3b7b78bf5562ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a669907e56274c6ca2838be3bf4a5ac9f" id="r_a669907e56274c6ca2838be3bf4a5ac9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a669907e56274c6ca2838be3bf4a5ac9f">GetSpacing</a> () const</td></tr>
<tr class="separator:a669907e56274c6ca2838be3bf4a5ac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b285752e1a79e123c055dc6fa95a50a" id="r_a1b285752e1a79e123c055dc6fa95a50a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b285752e1a79e123c055dc6fa95a50a">SetSpacing</a> (const std::vector&lt; double &gt; &amp;spacing)</td></tr>
<tr class="separator:a1b285752e1a79e123c055dc6fa95a50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7bd35f108a2df5c966285405af409548" id="r_a7bd35f108a2df5c966285405af409548"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bd35f108a2df5c966285405af409548">GetDirection</a> () const</td></tr>
<tr class="memdesc:a7bd35f108a2df5c966285405af409548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get the Direction.  <br /></td></tr>
<tr class="separator:a7bd35f108a2df5c966285405af409548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d6c8b3777b454b6da1ee1d3e7ed56f" id="r_a04d6c8b3777b454b6da1ee1d3e7ed56f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04d6c8b3777b454b6da1ee1d3e7ed56f">SetDirection</a> (const std::vector&lt; double &gt; &amp;direction)</td></tr>
<tr class="memdesc:a04d6c8b3777b454b6da1ee1d3e7ed56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get the Direction.  <br /></td></tr>
<tr class="separator:a04d6c8b3777b454b6da1ee1d3e7ed56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad0c57fd2e652cef42678df6721ee91ef" id="r_ad0c57fd2e652cef42678df6721ee91ef"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c57fd2e652cef42678df6721ee91ef">GetPixelAsInt8</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:ad0c57fd2e652cef42678df6721ee91ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:ad0c57fd2e652cef42678df6721ee91ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1e93337f99f36e695921bb1e699126" id="r_a9c1e93337f99f36e695921bb1e699126"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c1e93337f99f36e695921bb1e699126">GetPixelAsUInt8</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a9c1e93337f99f36e695921bb1e699126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a9c1e93337f99f36e695921bb1e699126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36e43923c39880321b04eda1436c4e2" id="r_ab36e43923c39880321b04eda1436c4e2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab36e43923c39880321b04eda1436c4e2">GetPixelAsInt16</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:ab36e43923c39880321b04eda1436c4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:ab36e43923c39880321b04eda1436c4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda2c933c0fc074041619f292d53b3f" id="r_a7bda2c933c0fc074041619f292d53b3f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bda2c933c0fc074041619f292d53b3f">GetPixelAsUInt16</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a7bda2c933c0fc074041619f292d53b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a7bda2c933c0fc074041619f292d53b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd014ee850c3b779b242577c795d568d" id="r_abd014ee850c3b779b242577c795d568d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd014ee850c3b779b242577c795d568d">GetPixelAsInt32</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:abd014ee850c3b779b242577c795d568d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:abd014ee850c3b779b242577c795d568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e68cff0ddbee6c0516d2f5436df4d3" id="r_a54e68cff0ddbee6c0516d2f5436df4d3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54e68cff0ddbee6c0516d2f5436df4d3">GetPixelAsUInt32</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a54e68cff0ddbee6c0516d2f5436df4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a54e68cff0ddbee6c0516d2f5436df4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1955c632dd4c04be1573d4dbadfcdec" id="r_ae1955c632dd4c04be1573d4dbadfcdec"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1955c632dd4c04be1573d4dbadfcdec">GetPixelAsInt64</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:ae1955c632dd4c04be1573d4dbadfcdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:ae1955c632dd4c04be1573d4dbadfcdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef2dd54b1b62e61e92026b92a8e8dfa" id="r_aeef2dd54b1b62e61e92026b92a8e8dfa"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeef2dd54b1b62e61e92026b92a8e8dfa">GetPixelAsUInt64</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:aeef2dd54b1b62e61e92026b92a8e8dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:aeef2dd54b1b62e61e92026b92a8e8dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e04ac6dc1e3a789f6b5f3fde6a704ad" id="r_a6e04ac6dc1e3a789f6b5f3fde6a704ad"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e04ac6dc1e3a789f6b5f3fde6a704ad">GetPixelAsFloat</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a6e04ac6dc1e3a789f6b5f3fde6a704ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a6e04ac6dc1e3a789f6b5f3fde6a704ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958fc359792de9213e87dc20f8fa400d" id="r_a958fc359792de9213e87dc20f8fa400d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a958fc359792de9213e87dc20f8fa400d">GetPixelAsDouble</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a958fc359792de9213e87dc20f8fa400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a958fc359792de9213e87dc20f8fa400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da3f19798a0c30488ab412e3d707505" id="r_a8da3f19798a0c30488ab412e3d707505"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8da3f19798a0c30488ab412e3d707505">GetPixelAsVectorInt8</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a8da3f19798a0c30488ab412e3d707505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a8da3f19798a0c30488ab412e3d707505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd696c8b0f218ea75c97c86db5983d2" id="r_acdd696c8b0f218ea75c97c86db5983d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdd696c8b0f218ea75c97c86db5983d2">GetPixelAsVectorUInt8</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:acdd696c8b0f218ea75c97c86db5983d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:acdd696c8b0f218ea75c97c86db5983d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115dd3ac39fe400bc5015a6f04231061" id="r_a115dd3ac39fe400bc5015a6f04231061"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a115dd3ac39fe400bc5015a6f04231061">GetPixelAsVectorInt16</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a115dd3ac39fe400bc5015a6f04231061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a115dd3ac39fe400bc5015a6f04231061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae280918c7fa7fa0f517442d82a1ca631" id="r_ae280918c7fa7fa0f517442d82a1ca631"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae280918c7fa7fa0f517442d82a1ca631">GetPixelAsVectorUInt16</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:ae280918c7fa7fa0f517442d82a1ca631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:ae280918c7fa7fa0f517442d82a1ca631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaf8347c90dcd454e2f2d87c3b9078c" id="r_a6eaf8347c90dcd454e2f2d87c3b9078c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eaf8347c90dcd454e2f2d87c3b9078c">GetPixelAsVectorInt32</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a6eaf8347c90dcd454e2f2d87c3b9078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a6eaf8347c90dcd454e2f2d87c3b9078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc761996e1b65903d7f003824da793f" id="r_aacc761996e1b65903d7f003824da793f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacc761996e1b65903d7f003824da793f">GetPixelAsVectorUInt32</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:aacc761996e1b65903d7f003824da793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:aacc761996e1b65903d7f003824da793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecd82663427b6ee5736ebc1dfedf51b" id="r_a0ecd82663427b6ee5736ebc1dfedf51b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ecd82663427b6ee5736ebc1dfedf51b">GetPixelAsVectorInt64</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a0ecd82663427b6ee5736ebc1dfedf51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a0ecd82663427b6ee5736ebc1dfedf51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa93e9578bcf1f93e6e4d0c9b85949e" id="r_affa93e9578bcf1f93e6e4d0c9b85949e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affa93e9578bcf1f93e6e4d0c9b85949e">GetPixelAsVectorUInt64</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:affa93e9578bcf1f93e6e4d0c9b85949e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:affa93e9578bcf1f93e6e4d0c9b85949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26348f6e3a42a837a455d611de8485e1" id="r_a26348f6e3a42a837a455d611de8485e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26348f6e3a42a837a455d611de8485e1">GetPixelAsVectorFloat32</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a26348f6e3a42a837a455d611de8485e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a26348f6e3a42a837a455d611de8485e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c9ed9277ffd2690aecc000e974c07" id="r_aab7c9ed9277ffd2690aecc000e974c07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab7c9ed9277ffd2690aecc000e974c07">GetPixelAsVectorFloat64</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:aab7c9ed9277ffd2690aecc000e974c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:aab7c9ed9277ffd2690aecc000e974c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb89bcefd90119d4b55407be5b30cc25" id="r_adb89bcefd90119d4b55407be5b30cc25"><td class="memItemLeft" align="right" valign="top">std::complex&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb89bcefd90119d4b55407be5b30cc25">GetPixelAsComplexFloat32</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:adb89bcefd90119d4b55407be5b30cc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:adb89bcefd90119d4b55407be5b30cc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1889da3071e6aa7daaa673db7be89266" id="r_a1889da3071e6aa7daaa673db7be89266"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1889da3071e6aa7daaa673db7be89266">GetPixelAsComplexFloat64</a> (const std::vector&lt; uint32_t &gt; &amp;idx) const</td></tr>
<tr class="memdesc:a1889da3071e6aa7daaa673db7be89266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a pixel.  <br /></td></tr>
<tr class="separator:a1889da3071e6aa7daaa673db7be89266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8c01f6319e38f168010c6c597465a146" id="r_a8c01f6319e38f168010c6c597465a146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c01f6319e38f168010c6c597465a146">SetPixelAsInt8</a> (const std::vector&lt; uint32_t &gt; &amp;idx, int8_t v)</td></tr>
<tr class="memdesc:a8c01f6319e38f168010c6c597465a146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a8c01f6319e38f168010c6c597465a146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe256cff6ccbcb37f89a61a83fda0763" id="r_abe256cff6ccbcb37f89a61a83fda0763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe256cff6ccbcb37f89a61a83fda0763">SetPixelAsUInt8</a> (const std::vector&lt; uint32_t &gt; &amp;idx, uint8_t v)</td></tr>
<tr class="memdesc:abe256cff6ccbcb37f89a61a83fda0763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:abe256cff6ccbcb37f89a61a83fda0763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75442c64fc1933c088c02ef11be5373a" id="r_a75442c64fc1933c088c02ef11be5373a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75442c64fc1933c088c02ef11be5373a">SetPixelAsInt16</a> (const std::vector&lt; uint32_t &gt; &amp;idx, int16_t v)</td></tr>
<tr class="memdesc:a75442c64fc1933c088c02ef11be5373a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a75442c64fc1933c088c02ef11be5373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50743b5a080be742524c461a4f1aa320" id="r_a50743b5a080be742524c461a4f1aa320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50743b5a080be742524c461a4f1aa320">SetPixelAsUInt16</a> (const std::vector&lt; uint32_t &gt; &amp;idx, uint16_t v)</td></tr>
<tr class="memdesc:a50743b5a080be742524c461a4f1aa320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a50743b5a080be742524c461a4f1aa320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9214c2b5437c831eff5a5ca220439c" id="r_a5b9214c2b5437c831eff5a5ca220439c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9214c2b5437c831eff5a5ca220439c">SetPixelAsInt32</a> (const std::vector&lt; uint32_t &gt; &amp;idx, int32_t v)</td></tr>
<tr class="memdesc:a5b9214c2b5437c831eff5a5ca220439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a5b9214c2b5437c831eff5a5ca220439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586633efa5fd70f1769a5e2255459264" id="r_a586633efa5fd70f1769a5e2255459264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a586633efa5fd70f1769a5e2255459264">SetPixelAsUInt32</a> (const std::vector&lt; uint32_t &gt; &amp;idx, uint32_t v)</td></tr>
<tr class="memdesc:a586633efa5fd70f1769a5e2255459264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a586633efa5fd70f1769a5e2255459264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2c9ff8b97b2ffd9c8a7b106377a0f8" id="r_a3f2c9ff8b97b2ffd9c8a7b106377a0f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f2c9ff8b97b2ffd9c8a7b106377a0f8">SetPixelAsInt64</a> (const std::vector&lt; uint32_t &gt; &amp;idx, int64_t v)</td></tr>
<tr class="memdesc:a3f2c9ff8b97b2ffd9c8a7b106377a0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a3f2c9ff8b97b2ffd9c8a7b106377a0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6088cb5d92145f9aec2f82b4b273dee5" id="r_a6088cb5d92145f9aec2f82b4b273dee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6088cb5d92145f9aec2f82b4b273dee5">SetPixelAsUInt64</a> (const std::vector&lt; uint32_t &gt; &amp;idx, uint64_t v)</td></tr>
<tr class="memdesc:a6088cb5d92145f9aec2f82b4b273dee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a6088cb5d92145f9aec2f82b4b273dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae243d0aa8d3a1f0b5c8a5335d21ae2e5" id="r_ae243d0aa8d3a1f0b5c8a5335d21ae2e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae243d0aa8d3a1f0b5c8a5335d21ae2e5">SetPixelAsFloat</a> (const std::vector&lt; uint32_t &gt; &amp;idx, float v)</td></tr>
<tr class="memdesc:ae243d0aa8d3a1f0b5c8a5335d21ae2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:ae243d0aa8d3a1f0b5c8a5335d21ae2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba546cc106fc7af755421fa6fe72871" id="r_a1ba546cc106fc7af755421fa6fe72871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ba546cc106fc7af755421fa6fe72871">SetPixelAsDouble</a> (const std::vector&lt; uint32_t &gt; &amp;idx, double v)</td></tr>
<tr class="memdesc:a1ba546cc106fc7af755421fa6fe72871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a1ba546cc106fc7af755421fa6fe72871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e10b7b03904ff90b38e9cc92ccf1ef" id="r_a88e10b7b03904ff90b38e9cc92ccf1ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88e10b7b03904ff90b38e9cc92ccf1ef">SetPixelAsVectorInt8</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; int8_t &gt; &amp;v)</td></tr>
<tr class="memdesc:a88e10b7b03904ff90b38e9cc92ccf1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a88e10b7b03904ff90b38e9cc92ccf1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e53202d40fd48f6d4b9fb55f2ed9c6d" id="r_a1e53202d40fd48f6d4b9fb55f2ed9c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e53202d40fd48f6d4b9fb55f2ed9c6d">SetPixelAsVectorUInt8</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; uint8_t &gt; &amp;v)</td></tr>
<tr class="memdesc:a1e53202d40fd48f6d4b9fb55f2ed9c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a1e53202d40fd48f6d4b9fb55f2ed9c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235e853836366fac8ee98de3d80fb866" id="r_a235e853836366fac8ee98de3d80fb866"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235e853836366fac8ee98de3d80fb866">SetPixelAsVectorInt16</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; int16_t &gt; &amp;v)</td></tr>
<tr class="memdesc:a235e853836366fac8ee98de3d80fb866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a235e853836366fac8ee98de3d80fb866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3627592f3f167e398a3b4b43ab1d91" id="r_a7d3627592f3f167e398a3b4b43ab1d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d3627592f3f167e398a3b4b43ab1d91">SetPixelAsVectorUInt16</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; uint16_t &gt; &amp;v)</td></tr>
<tr class="memdesc:a7d3627592f3f167e398a3b4b43ab1d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a7d3627592f3f167e398a3b4b43ab1d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8b8d47857d714e5c1cc06f0dc78b43" id="r_a8c8b8d47857d714e5c1cc06f0dc78b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c8b8d47857d714e5c1cc06f0dc78b43">SetPixelAsVectorInt32</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; int32_t &gt; &amp;v)</td></tr>
<tr class="memdesc:a8c8b8d47857d714e5c1cc06f0dc78b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a8c8b8d47857d714e5c1cc06f0dc78b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6ae62b2ba271d90764e03ba3155f3f" id="r_aeb6ae62b2ba271d90764e03ba3155f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb6ae62b2ba271d90764e03ba3155f3f">SetPixelAsVectorUInt32</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; uint32_t &gt; &amp;v)</td></tr>
<tr class="memdesc:aeb6ae62b2ba271d90764e03ba3155f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:aeb6ae62b2ba271d90764e03ba3155f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab595292b40ced613b36411608f1408a9" id="r_ab595292b40ced613b36411608f1408a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab595292b40ced613b36411608f1408a9">SetPixelAsVectorInt64</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; int64_t &gt; &amp;v)</td></tr>
<tr class="memdesc:ab595292b40ced613b36411608f1408a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:ab595292b40ced613b36411608f1408a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc04519f671706868e9c642cf1e4dad" id="r_aecc04519f671706868e9c642cf1e4dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecc04519f671706868e9c642cf1e4dad">SetPixelAsVectorUInt64</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; uint64_t &gt; &amp;v)</td></tr>
<tr class="memdesc:aecc04519f671706868e9c642cf1e4dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:aecc04519f671706868e9c642cf1e4dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862c2f02ce7abc80943e1cbbb75f8954" id="r_a862c2f02ce7abc80943e1cbbb75f8954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a862c2f02ce7abc80943e1cbbb75f8954">SetPixelAsVectorFloat32</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; float &gt; &amp;v)</td></tr>
<tr class="memdesc:a862c2f02ce7abc80943e1cbbb75f8954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:a862c2f02ce7abc80943e1cbbb75f8954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0326247d1ca5051fba7d1c07b676099" id="r_ae0326247d1ca5051fba7d1c07b676099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0326247d1ca5051fba7d1c07b676099">SetPixelAsVectorFloat64</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="memdesc:ae0326247d1ca5051fba7d1c07b676099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:ae0326247d1ca5051fba7d1c07b676099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff869ab52a6b49bfbb4caa4a8ade6209" id="r_aff869ab52a6b49bfbb4caa4a8ade6209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff869ab52a6b49bfbb4caa4a8ade6209">SetPixelAsComplexFloat32</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::complex&lt; float &gt; v)</td></tr>
<tr class="memdesc:aff869ab52a6b49bfbb4caa4a8ade6209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:aff869ab52a6b49bfbb4caa4a8ade6209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb107c591ef00628fe9b3d3ff8b369ac" id="r_adb107c591ef00628fe9b3d3ff8b369ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb107c591ef00628fe9b3d3ff8b369ac">SetPixelAsComplexFloat64</a> (const std::vector&lt; uint32_t &gt; &amp;idx, const std::complex&lt; double &gt; v)</td></tr>
<tr class="memdesc:adb107c591ef00628fe9b3d3ff8b369ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pixel.  <br /></td></tr>
<tr class="separator:adb107c591ef00628fe9b3d3ff8b369ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa638d156039b08584904cda2e20157c1" id="r_aa638d156039b08584904cda2e20157c1"><td class="memItemLeft" align="right" valign="top">int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa638d156039b08584904cda2e20157c1">GetBufferAsInt8</a> ()</td></tr>
<tr class="memdesc:aa638d156039b08584904cda2e20157c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:aa638d156039b08584904cda2e20157c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b011a5e138e90d1375955ba271533a8" id="r_a9b011a5e138e90d1375955ba271533a8"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b011a5e138e90d1375955ba271533a8">GetBufferAsUInt8</a> ()</td></tr>
<tr class="memdesc:a9b011a5e138e90d1375955ba271533a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a9b011a5e138e90d1375955ba271533a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f6a12886842f236958f8b3e89833c7" id="r_a69f6a12886842f236958f8b3e89833c7"><td class="memItemLeft" align="right" valign="top">int16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f6a12886842f236958f8b3e89833c7">GetBufferAsInt16</a> ()</td></tr>
<tr class="memdesc:a69f6a12886842f236958f8b3e89833c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a69f6a12886842f236958f8b3e89833c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfa9b811d8cd281dae9e207dbf4c192" id="r_a8bfa9b811d8cd281dae9e207dbf4c192"><td class="memItemLeft" align="right" valign="top">uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bfa9b811d8cd281dae9e207dbf4c192">GetBufferAsUInt16</a> ()</td></tr>
<tr class="memdesc:a8bfa9b811d8cd281dae9e207dbf4c192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a8bfa9b811d8cd281dae9e207dbf4c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce813ee554356d8153701bebca63981" id="r_a7ce813ee554356d8153701bebca63981"><td class="memItemLeft" align="right" valign="top">int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ce813ee554356d8153701bebca63981">GetBufferAsInt32</a> ()</td></tr>
<tr class="memdesc:a7ce813ee554356d8153701bebca63981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a7ce813ee554356d8153701bebca63981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c7fff9e735d24c0a4dbe244ee92f6" id="r_a1b7c7fff9e735d24c0a4dbe244ee92f6"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b7c7fff9e735d24c0a4dbe244ee92f6">GetBufferAsUInt32</a> ()</td></tr>
<tr class="memdesc:a1b7c7fff9e735d24c0a4dbe244ee92f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a1b7c7fff9e735d24c0a4dbe244ee92f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d1ac71dc6d45175ce08c3ae2b12539" id="r_a14d1ac71dc6d45175ce08c3ae2b12539"><td class="memItemLeft" align="right" valign="top">int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14d1ac71dc6d45175ce08c3ae2b12539">GetBufferAsInt64</a> ()</td></tr>
<tr class="memdesc:a14d1ac71dc6d45175ce08c3ae2b12539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a14d1ac71dc6d45175ce08c3ae2b12539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6049da4ed7956e16faf093ec63778389" id="r_a6049da4ed7956e16faf093ec63778389"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6049da4ed7956e16faf093ec63778389">GetBufferAsUInt64</a> ()</td></tr>
<tr class="memdesc:a6049da4ed7956e16faf093ec63778389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a6049da4ed7956e16faf093ec63778389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad896f3be099548ad24a160aa1a4ed357" id="r_ad896f3be099548ad24a160aa1a4ed357"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad896f3be099548ad24a160aa1a4ed357">GetBufferAsFloat</a> ()</td></tr>
<tr class="memdesc:ad896f3be099548ad24a160aa1a4ed357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:ad896f3be099548ad24a160aa1a4ed357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f6ed5fff8ee5d371e6a3671d0cae6a" id="r_ab7f6ed5fff8ee5d371e6a3671d0cae6a"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7f6ed5fff8ee5d371e6a3671d0cae6a">GetBufferAsDouble</a> ()</td></tr>
<tr class="memdesc:ab7f6ed5fff8ee5d371e6a3671d0cae6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:ab7f6ed5fff8ee5d371e6a3671d0cae6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827ddb6ba0b3e4e351802ce3e65c23e1" id="r_a827ddb6ba0b3e4e351802ce3e65c23e1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a827ddb6ba0b3e4e351802ce3e65c23e1">GetBufferAsVoid</a> ()</td></tr>
<tr class="memdesc:a827ddb6ba0b3e4e351802ce3e65c23e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a827ddb6ba0b3e4e351802ce3e65c23e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69898006932ab663c6d1ce6775367821" id="r_a69898006932ab663c6d1ce6775367821"><td class="memItemLeft" align="right" valign="top">const int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69898006932ab663c6d1ce6775367821">GetBufferAsInt8</a> () const</td></tr>
<tr class="memdesc:a69898006932ab663c6d1ce6775367821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a69898006932ab663c6d1ce6775367821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1f0a6dc3bfd68cc3c6c400d23ef23c" id="r_a2b1f0a6dc3bfd68cc3c6c400d23ef23c"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b1f0a6dc3bfd68cc3c6c400d23ef23c">GetBufferAsUInt8</a> () const</td></tr>
<tr class="memdesc:a2b1f0a6dc3bfd68cc3c6c400d23ef23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a2b1f0a6dc3bfd68cc3c6c400d23ef23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa805efe6118819d5d2e41fdd2dd5f57d" id="r_aa805efe6118819d5d2e41fdd2dd5f57d"><td class="memItemLeft" align="right" valign="top">const int16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa805efe6118819d5d2e41fdd2dd5f57d">GetBufferAsInt16</a> () const</td></tr>
<tr class="memdesc:aa805efe6118819d5d2e41fdd2dd5f57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:aa805efe6118819d5d2e41fdd2dd5f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3de1a5a1ec46d65f23f985abf37b938" id="r_ad3de1a5a1ec46d65f23f985abf37b938"><td class="memItemLeft" align="right" valign="top">const uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3de1a5a1ec46d65f23f985abf37b938">GetBufferAsUInt16</a> () const</td></tr>
<tr class="memdesc:ad3de1a5a1ec46d65f23f985abf37b938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:ad3de1a5a1ec46d65f23f985abf37b938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7d8fe774ea0535c2dbe6001a129e40" id="r_aae7d8fe774ea0535c2dbe6001a129e40"><td class="memItemLeft" align="right" valign="top">const int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae7d8fe774ea0535c2dbe6001a129e40">GetBufferAsInt32</a> () const</td></tr>
<tr class="memdesc:aae7d8fe774ea0535c2dbe6001a129e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:aae7d8fe774ea0535c2dbe6001a129e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe46fa62d720c617997736d91ca96ca" id="r_aebe46fa62d720c617997736d91ca96ca"><td class="memItemLeft" align="right" valign="top">const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe46fa62d720c617997736d91ca96ca">GetBufferAsUInt32</a> () const</td></tr>
<tr class="memdesc:aebe46fa62d720c617997736d91ca96ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:aebe46fa62d720c617997736d91ca96ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577e6c1b579b0dd626a75c2d87086b06" id="r_a577e6c1b579b0dd626a75c2d87086b06"><td class="memItemLeft" align="right" valign="top">const int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a577e6c1b579b0dd626a75c2d87086b06">GetBufferAsInt64</a> () const</td></tr>
<tr class="memdesc:a577e6c1b579b0dd626a75c2d87086b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a577e6c1b579b0dd626a75c2d87086b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a79f8ee1d6d1c118baeab9708f80e1" id="r_ac2a79f8ee1d6d1c118baeab9708f80e1"><td class="memItemLeft" align="right" valign="top">const uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2a79f8ee1d6d1c118baeab9708f80e1">GetBufferAsUInt64</a> () const</td></tr>
<tr class="memdesc:ac2a79f8ee1d6d1c118baeab9708f80e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:ac2a79f8ee1d6d1c118baeab9708f80e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab903a0f7917525347ed46d3d658e057d" id="r_ab903a0f7917525347ed46d3d658e057d"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab903a0f7917525347ed46d3d658e057d">GetBufferAsFloat</a> () const</td></tr>
<tr class="memdesc:ab903a0f7917525347ed46d3d658e057d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:ab903a0f7917525347ed46d3d658e057d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ad1cd0da557e6bdadacd027d5e95c5" id="r_a12ad1cd0da557e6bdadacd027d5e95c5"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12ad1cd0da557e6bdadacd027d5e95c5">GetBufferAsDouble</a> () const</td></tr>
<tr class="memdesc:a12ad1cd0da557e6bdadacd027d5e95c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:a12ad1cd0da557e6bdadacd027d5e95c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd4b5ac2632c7dcc33b971229a51be6" id="r_aabd4b5ac2632c7dcc33b971229a51be6"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabd4b5ac2632c7dcc33b971229a51be6">GetBufferAsVoid</a> () const</td></tr>
<tr class="memdesc:aabd4b5ac2632c7dcc33b971229a51be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the image buffer.  <br /></td></tr>
<tr class="separator:aabd4b5ac2632c7dcc33b971229a51be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a62caf35a0504c5c761abdf71d4018a89" id="r_a62caf35a0504c5c761abdf71d4018a89"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62caf35a0504c5c761abdf71d4018a89">DefaultImageCoordinateTolerance</a> = 1e-6</td></tr>
<tr class="separator:a62caf35a0504c5c761abdf71d4018a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f5123f49cd495f86349f7e06a49c3d" id="r_aa0f5123f49cd495f86349f7e06a49c3d"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0f5123f49cd495f86349f7e06a49c3d">DefaultImageDirectionTolerance</a> = 1e-6</td></tr>
<tr class="separator:aa0f5123f49cd495f86349f7e06a49c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1cd9b3cdfa9e9159f48cf84ef4461d55" id="r_a1cd9b3cdfa9e9159f48cf84ef4461d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cd9b3cdfa9e9159f48cf84ef4461d55">Allocate</a> (const std::vector&lt; unsigned int &gt; &amp;size, <a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> valueEnum, unsigned int numberOfComponents)</td></tr>
<tr class="memdesc:a1cd9b3cdfa9e9159f48cf84ef4461d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods called by the constructor to allocate and initialize an image.  <br /></td></tr>
<tr class="separator:a1cd9b3cdfa9e9159f48cf84ef4461d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9c851b17d466dd6d0fc2401aefa9cdec" id="r_a9c851b17d466dd6d0fc2401aefa9cdec"><td class="memTemplParams" colspan="2">template&lt;class TImageType&gt; </td></tr>
<tr class="memitem:a9c851b17d466dd6d0fc2401aefa9cdec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c851b17d466dd6d0fc2401aefa9cdec">AllocateInternal</a> (const std::vector&lt; unsigned int &gt; &amp;size, unsigned int numberOfComponents)</td></tr>
<tr class="memdesc:a9c851b17d466dd6d0fc2401aefa9cdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates images of different types.  <br /></td></tr>
<tr class="separator:a9c851b17d466dd6d0fc2401aefa9cdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a871c21759c1ae4db59ec0fbce2d3fe75" id="r_a871c21759c1ae4db59ec0fbce2d3fe75"><td class="memTemplParams" colspan="2">template&lt;class TImageType&gt; </td></tr>
<tr class="memitem:a871c21759c1ae4db59ec0fbce2d3fe75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a871c21759c1ae4db59ec0fbce2d3fe75">ToVectorInternal</a> (bool inPlace)</td></tr>
<tr class="memdesc:a871c21759c1ae4db59ec0fbce2d3fe75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal methods for converting images between vectors and scalars.  <br /></td></tr>
<tr class="separator:a871c21759c1ae4db59ec0fbce2d3fe75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ef31f237592ffbff6132c13fd834c1" id="r_a19ef31f237592ffbff6132c13fd834c1"><td class="memTemplParams" colspan="2">template&lt;class TImageType&gt; </td></tr>
<tr class="memitem:a19ef31f237592ffbff6132c13fd834c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19ef31f237592ffbff6132c13fd834c1">ToScalarInternal</a> (bool inPlace)</td></tr>
<tr class="memdesc:a19ef31f237592ffbff6132c13fd834c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal methods for converting images between vectors and scalars.  <br /></td></tr>
<tr class="separator:a19ef31f237592ffbff6132c13fd834c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a055bac850034fb5c2ce892381318627f" id="r_a055bac850034fb5c2ce892381318627f"><td class="memTemplParams" colspan="2">template&lt;typename TImageType&gt; </td></tr>
<tr class="memitem:a055bac850034fb5c2ce892381318627f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1simple_1_1PimpleImageBase.html">PimpleImageBase</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a055bac850034fb5c2ce892381318627f">DispatchedInternalInitialization</a> (<a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> *image)</td></tr>
<tr class="separator:a055bac850034fb5c2ce892381318627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132d8e75efaac108242665c48150f343" id="r_a132d8e75efaac108242665c48150f343"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a132d8e75efaac108242665c48150f343">Image</a> (std::unique_ptr&lt; <a class="el" href="classitk_1_1simple_1_1PimpleImageBase.html">PimpleImageBase</a> &gt; pimpleImage)</td></tr>
<tr class="separator:a132d8e75efaac108242665c48150f343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1318ae056ca7ccda06025b2c775db4" id="r_a8b1318ae056ca7ccda06025b2c775db4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b1318ae056ca7ccda06025b2c775db4">InternalInitialization</a> (<a class="el" href="namespaceitk_1_1simple.html#aaf027344ec3011c3ac6fcfd77271bb75">PixelIDValueType</a> type, unsigned int dimension, <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> *image)</td></tr>
<tr class="separator:a8b1318ae056ca7ccda06025b2c775db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a58d8e24a3e9421653f5550a3d191ee58" id="r_a58d8e24a3e9421653f5550a3d191ee58"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classitk_1_1simple_1_1PimpleImageBase.html">PimpleImageBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d8e24a3e9421653f5550a3d191ee58">m_PimpleImage</a></td></tr>
<tr class="separator:a58d8e24a3e9421653f5550a3d191ee58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aaf84f462b2cb8fd9088d79765360285a" id="r_aaf84f462b2cb8fd9088d79765360285a"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf84f462b2cb8fd9088d79765360285a">AllocateMemberFunctionAddressor</a></td></tr>
<tr class="separator:aaf84f462b2cb8fd9088d79765360285a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9abddb4e526202df2e9408f7437d250" id="r_aa9abddb4e526202df2e9408f7437d250"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9abddb4e526202df2e9408f7437d250">DispatchedInternalInitialiationAddressor</a></td></tr>
<tr class="separator:aa9abddb4e526202df2e9408f7437d250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de5bb1d9d0940a24c82985d120d403e" id="r_a9de5bb1d9d0940a24c82985d120d403e"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de5bb1d9d0940a24c82985d120d403e">ToScalarAddressor</a></td></tr>
<tr class="separator:a9de5bb1d9d0940a24c82985d120d403e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3f2c20fd85558f113d50dd7e8c385a" id="r_a5a3f2c20fd85558f113d50dd7e8c385a"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a3f2c20fd85558f113d50dd7e8c385a">ToVectorAddressor</a></td></tr>
<tr class="separator:a5a3f2c20fd85558f113d50dd7e8c385a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5f3a8beb0170782f77853b044ddd02a4" name="a5f3a8beb0170782f77853b044ddd02a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3a8beb0170782f77853b044ddd02a4">&#9670;&#160;</a></span>Self</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5f3a8beb0170782f77853b044ddd02a4">itk::simple::Image::Self</a> = <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00079">79</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adef33af720d7ce65533fbb10b2b53f51" name="adef33af720d7ce65533fbb10b2b53f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef33af720d7ce65533fbb10b2b53f51">&#9670;&#160;</a></span>~Image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual itk::simple::Image::~Image </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42a8055958ef17e5fd3602e68e28fcc7" name="a42a8055958ef17e5fd3602e68e28fcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a8055958ef17e5fd3602e68e28fcc7">&#9670;&#160;</a></span>Image() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor, creates an image of size 0. </p>

<p class="reference">Referenced by <a class="el" href="#a9c851b17d466dd6d0fc2401aefa9cdec">AllocateInternal()</a>, <a class="el" href="#afa8a4757400c414e809d1767ee616bd0">CopyInformation()</a>, <a class="el" href="#ae3a51dbe990dae1370afe39a65103527">Image()</a>, <a class="el" href="#af92e6ec5a7b76f66671d14480906aef0">Image()</a>, <a class="el" href="sitkImage_8h_source.html#l00165">Image()</a>, <a class="el" href="sitkImage_8h_source.html#l00170">Image()</a>, <a class="el" href="#a69467355f435bc8ec5749402679ce0b1">IsCongruentImageGeometry()</a>, <a class="el" href="#a5422fe56eb946fc813b85d134a36da13">IsSameImageGeometryAs()</a>, <a class="el" href="#a544257ed6b37d939c081af1c18753b2c">operator=()</a>, <a class="el" href="#abd7c186de418cc97050e3ced622cf8c2">operator=()</a>, <a class="el" href="#a47c9fa1902dae8f984bda1bdeafa4a3c">ToString()</a>, <a class="el" href="#ad6ee03fbbfe962cd2b5b39ef9fc4df44">ToVectorImage()</a>, and <a class="el" href="#a871c21759c1ae4db59ec0fbce2d3fe75">ToVectorInternal()</a>.</p>

</div>
</div>
<a id="ae3a51dbe990dae1370afe39a65103527" name="ae3a51dbe990dae1370afe39a65103527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a51dbe990dae1370afe39a65103527">&#9670;&#160;</a></span>Image() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="af92e6ec5a7b76f66671d14480906aef0" name="af92e6ec5a7b76f66671d14480906aef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92e6ec5a7b76f66671d14480906aef0">&#9670;&#160;</a></span>Image() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor and assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>After the operation img is valid only for destructing and assignment; all other operations have undefined behavior. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="a14b96e088ce9f8d72f3c71663b376476" name="a14b96e088ce9f8d72f3c71663b376476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b96e088ce9f8d72f3c71663b376476">&#9670;&#160;</a></span>Image() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a></td>          <td class="paramname"><span class="paramname"><em>valueEnum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified. </p>
<p>If the pixel type is a scalar or a label pixel type, then the number of components must be specified as 0 or 1.</p>
<p>If the pixel type is a vector pixel type, then the number of components defaults to the image dimension, unless the numberOfComponents is explicitly specified.</p>
<p>Unlike the standard convention for Dimensional Vectors the size parameter must be the exact dimension requesting. That is, it must be of length 2 of a 2D image, 3 for a 3D image and 4 for a 4D image. </p>

</div>
</div>
<a id="a619f5f36459b477581b3d7f0c99d1f9c" name="a619f5f36459b477581b3d7f0c99d1f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619f5f36459b477581b3d7f0c99d1f9c">&#9670;&#160;</a></span>Image() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a></td>          <td class="paramname"><span class="paramname"><em>valueEnum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified. </p>
<p>If the pixel type is a scalar or a label pixel type, then the number of components must be specified as 0 or 1.</p>
<p>If the pixel type is a vector pixel type, then the number of components defaults to the image dimension, unless the numberOfComponents is explicitly specified.</p>
<p>Unlike the standard convention for Dimensional Vectors the size parameter must be the exact dimension requesting. That is, it must be of length 2 of a 2D image, 3 for a 3D image and 4 for a 4D image. </p>

</div>
</div>
<a id="affc77be35235acbc1b67e60e7670194c" name="affc77be35235acbc1b67e60e7670194c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc77be35235acbc1b67e60e7670194c">&#9670;&#160;</a></span>Image() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a></td>          <td class="paramname"><span class="paramname"><em>valueEnum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>numberOfComponents</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors for 2D, 3D an optionally 4D images where pixel type and number of components can be specified. </p>
<p>If the pixel type is a scalar or a label pixel type, then the number of components must be specified as 0 or 1.</p>
<p>If the pixel type is a vector pixel type, then the number of components defaults to the image dimension, unless the numberOfComponents is explicitly specified.</p>
<p>Unlike the standard convention for Dimensional Vectors the size parameter must be the exact dimension requesting. That is, it must be of length 2 of a 2D image, 3 for a 3D image and 4 for a 4D image. </p>

</div>
</div>
<a id="a1b10a5a2f14a9bec516ff47bcba96761" name="a1b10a5a2f14a9bec516ff47bcba96761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b10a5a2f14a9bec516ff47bcba96761">&#9670;&#160;</a></span>Image() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1SmartPointer.html">itk::SmartPointer</a>&lt; TImageType &gt;</td>          <td class="paramname"><span class="paramname"><em>image</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> from an pointer to an ITK image. </p>
<p>The SimpleITK image will add a reference to the underlying the ITK image and hold a pointer to the image. If the image is manipulated directly from the ITK interface, SimpleITK may be unaware of it, and may cause complication related to aliasing and SimpleITK copy on write policy.</p>
<p>If simpleITK does not support the image type, a compile-time error or assertion will fail.</p>
<p>The ITK image must be fully buffered, and must have a zero starting index for the Buffered/Largest regions. </p>

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00165">165</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="a135e55d13e3baf01d3cd906d40558605" name="a135e55d13e3baf01d3cd906d40558605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135e55d13e3baf01d3cd906d40558605">&#9670;&#160;</a></span>Image() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">TImageType *</td>          <td class="paramname"><span class="paramname"><em>image</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> from an pointer to an ITK image. </p>
<p>The SimpleITK image will add a reference to the underlying the ITK image and hold a pointer to the image. If the image is manipulated directly from the ITK interface, SimpleITK may be unaware of it, and may cause complication related to aliasing and SimpleITK copy on write policy.</p>
<p>If simpleITK does not support the image type, a compile-time error or assertion will fail.</p>
<p>The ITK image must be fully buffered, and must have a zero starting index for the Buffered/Largest regions. </p>

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00170">170</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>, <a class="el" href="#a8b1318ae056ca7ccda06025b2c775db4">InternalInitialization()</a>, <a class="el" href="sitkPixelIDValues_8h_source.html#l00047">itk::simple::ImageTypeToPixelIDValue&lt; TImageType &gt;::Result</a>, <a class="el" href="sitkConfigure_8h_source.html#l00030">SITK_MAX_DIMENSION</a>, and <a class="el" href="sitkPixelIDValues_8h_source.html#l00102">itk::simple::sitkUnknown</a>.</p>

</div>
</div>
<a id="a132d8e75efaac108242665c48150f343" name="a132d8e75efaac108242665c48150f343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132d8e75efaac108242665c48150f343">&#9670;&#160;</a></span>Image() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::simple::Image::Image </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classitk_1_1simple_1_1PimpleImageBase.html">PimpleImageBase</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pimpleImage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1cd9b3cdfa9e9159f48cf84ef4461d55" name="a1cd9b3cdfa9e9159f48cf84ef4461d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd9b3cdfa9e9159f48cf84ef4461d55">&#9670;&#160;</a></span>Allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::Allocate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a></td>          <td class="paramname"><span class="paramname"><em>valueEnum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>numberOfComponents</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods called by the constructor to allocate and initialize an image. </p>
<p>This method internally utilizes the member function factory to dispatch to methods instantiated on the image of the pixel ID </p>

</div>
</div>
<a id="a9c851b17d466dd6d0fc2401aefa9cdec" name="a9c851b17d466dd6d0fc2401aefa9cdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c851b17d466dd6d0fc2401aefa9cdec">&#9670;&#160;</a></span>AllocateInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TImageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::AllocateInternal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>numberOfComponents</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates images of different types. </p>

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="afa8a4757400c414e809d1767ee616bd0" name="afa8a4757400c414e809d1767ee616bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8a4757400c414e809d1767ee616bd0">&#9670;&#160;</a></span>CopyInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::CopyInformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcImage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy common meta-data from an image to this one. </p>
<p>Copies the Origin, Spacing, and Direction from the source image to this image. The meta-data dictionary is <b>not</b> copied.</p>
<p>It is required for the source <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a>'s dimension and size to match, this image's attributes, otherwise an exception will be generated. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ImageRegistrationMethodDisplacement1_2ImageRegistrationMethodDisplacement1_8cxx-example.html#a25">ImageRegistrationMethodDisplacement1/ImageRegistrationMethodDisplacement1.cxx</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="a055bac850034fb5c2ce892381318627f" name="a055bac850034fb5c2ce892381318627f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055bac850034fb5c2ce892381318627f">&#9670;&#160;</a></span>DispatchedInternalInitialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1PimpleImageBase.html">PimpleImageBase</a> * itk::simple::Image::DispatchedInternalInitialization </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> *</td>          <td class="paramname"><span class="paramname"><em>image</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5c224f1f5173836258dbb983341a2f9" name="af5c224f1f5173836258dbb983341a2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c224f1f5173836258dbb983341a2f9">&#9670;&#160;</a></span>EraseMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::simple::Image::EraseMetaData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an entry from the meta-data dictionary. </p>
<p>Returns true, when the value exists in the dictionary and is removed, false otherwise. </p>

</div>
</div>
<a id="a393912859bda381a8b7b0ec79cfce4a1" name="a393912859bda381a8b7b0ec79cfce4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393912859bda381a8b7b0ec79cfce4a1">&#9670;&#160;</a></span>EvaluateAtContinuousIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::EvaluateAtContinuousIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5">InterpolatorEnum</a></td>          <td class="paramname"><span class="paramname"><em>interp</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5ab1d3c20fe43968ed72c71ae2a59d860a">sitkLinear</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate pixel value at a continuous index. </p>
<p>This method is not supported for <a class="elRef" href="https://www.itk.org/Doxygen/html/classLabel.html">Label</a> pixel types.</p>
<p>The valid range of continuous index is [-0.5, size-0.5] for each dimension. An exception is thrown if index is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The continuous index must be at least the length of the image dimension. </td></tr>
    <tr><td class="paramname">interp</td><td>The interpolation type to use, only sitkNearest and sitkLinear are supported for <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All supported pixel types are returned as an array, where complex numbers are returned with the real followed by the complex component. </dd></dl>

<p class="reference">References <a class="el" href="sitkInterpolator_8h_source.html#l00038">itk::simple::sitkLinear</a>.</p>

</div>
</div>
<a id="aa2f96579d0f3da2d1a3b48d4e1037fbc" name="aa2f96579d0f3da2d1a3b48d4e1037fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f96579d0f3da2d1a3b48d4e1037fbc">&#9670;&#160;</a></span>EvaluateAtPhysicalPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::EvaluateAtPhysicalPoint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5">InterpolatorEnum</a></td>          <td class="paramname"><span class="paramname"><em>interp</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceitk_1_1simple.html#a7cb1ef8bd02c669c02ea2f9f5aa374e5ab1d3c20fe43968ed72c71ae2a59d860a">sitkLinear</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate pixel value at a physical point.</p>
<p>This method is not supported for <a class="elRef" href="https://www.itk.org/Doxygen/html/classLabel.html">Label</a> pixel types.</p>
<p>An exception is thrown if the point is out of the defined region for the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The physical point at which the interpolation is computed. </td></tr>
    <tr><td class="paramname">interp</td><td>The interpolation type to use, only sitkNearest and sitkLinear are supported for <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All supported pixel types are returned as an array, where complex numbers are returned with the real followed by the complex component. </dd></dl>

<p class="reference">References <a class="el" href="sitkInterpolator_8h_source.html#l00038">itk::simple::sitkLinear</a>.</p>

</div>
</div>
<a id="ab7f6ed5fff8ee5d371e6a3671d0cae6a" name="ab7f6ed5fff8ee5d371e6a3671d0cae6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f6ed5fff8ee5d371e6a3671d0cae6a">&#9670;&#160;</a></span>GetBufferAsDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * itk::simple::Image::GetBufferAsDouble </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a12ad1cd0da557e6bdadacd027d5e95c5" name="a12ad1cd0da557e6bdadacd027d5e95c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ad1cd0da557e6bdadacd027d5e95c5">&#9670;&#160;</a></span>GetBufferAsDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double * itk::simple::Image::GetBufferAsDouble </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ad896f3be099548ad24a160aa1a4ed357" name="ad896f3be099548ad24a160aa1a4ed357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad896f3be099548ad24a160aa1a4ed357">&#9670;&#160;</a></span>GetBufferAsFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * itk::simple::Image::GetBufferAsFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ab903a0f7917525347ed46d3d658e057d" name="ab903a0f7917525347ed46d3d658e057d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab903a0f7917525347ed46d3d658e057d">&#9670;&#160;</a></span>GetBufferAsFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float * itk::simple::Image::GetBufferAsFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a69f6a12886842f236958f8b3e89833c7" name="a69f6a12886842f236958f8b3e89833c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f6a12886842f236958f8b3e89833c7">&#9670;&#160;</a></span>GetBufferAsInt16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t * itk::simple::Image::GetBufferAsInt16 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aa805efe6118819d5d2e41fdd2dd5f57d" name="aa805efe6118819d5d2e41fdd2dd5f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa805efe6118819d5d2e41fdd2dd5f57d">&#9670;&#160;</a></span>GetBufferAsInt16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int16_t * itk::simple::Image::GetBufferAsInt16 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a7ce813ee554356d8153701bebca63981" name="a7ce813ee554356d8153701bebca63981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce813ee554356d8153701bebca63981">&#9670;&#160;</a></span>GetBufferAsInt32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t * itk::simple::Image::GetBufferAsInt32 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aae7d8fe774ea0535c2dbe6001a129e40" name="aae7d8fe774ea0535c2dbe6001a129e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7d8fe774ea0535c2dbe6001a129e40">&#9670;&#160;</a></span>GetBufferAsInt32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t * itk::simple::Image::GetBufferAsInt32 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a14d1ac71dc6d45175ce08c3ae2b12539" name="a14d1ac71dc6d45175ce08c3ae2b12539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d1ac71dc6d45175ce08c3ae2b12539">&#9670;&#160;</a></span>GetBufferAsInt64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t * itk::simple::Image::GetBufferAsInt64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a577e6c1b579b0dd626a75c2d87086b06" name="a577e6c1b579b0dd626a75c2d87086b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577e6c1b579b0dd626a75c2d87086b06">&#9670;&#160;</a></span>GetBufferAsInt64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t * itk::simple::Image::GetBufferAsInt64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aa638d156039b08584904cda2e20157c1" name="aa638d156039b08584904cda2e20157c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa638d156039b08584904cda2e20157c1">&#9670;&#160;</a></span>GetBufferAsInt8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t * itk::simple::Image::GetBufferAsInt8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a69898006932ab663c6d1ce6775367821" name="a69898006932ab663c6d1ce6775367821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69898006932ab663c6d1ce6775367821">&#9670;&#160;</a></span>GetBufferAsInt8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t * itk::simple::Image::GetBufferAsInt8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a8bfa9b811d8cd281dae9e207dbf4c192" name="a8bfa9b811d8cd281dae9e207dbf4c192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfa9b811d8cd281dae9e207dbf4c192">&#9670;&#160;</a></span>GetBufferAsUInt16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t * itk::simple::Image::GetBufferAsUInt16 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ad3de1a5a1ec46d65f23f985abf37b938" name="ad3de1a5a1ec46d65f23f985abf37b938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3de1a5a1ec46d65f23f985abf37b938">&#9670;&#160;</a></span>GetBufferAsUInt16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t * itk::simple::Image::GetBufferAsUInt16 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1b7c7fff9e735d24c0a4dbe244ee92f6" name="a1b7c7fff9e735d24c0a4dbe244ee92f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7c7fff9e735d24c0a4dbe244ee92f6">&#9670;&#160;</a></span>GetBufferAsUInt32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t * itk::simple::Image::GetBufferAsUInt32 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aebe46fa62d720c617997736d91ca96ca" name="aebe46fa62d720c617997736d91ca96ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe46fa62d720c617997736d91ca96ca">&#9670;&#160;</a></span>GetBufferAsUInt32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t * itk::simple::Image::GetBufferAsUInt32 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a6049da4ed7956e16faf093ec63778389" name="a6049da4ed7956e16faf093ec63778389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6049da4ed7956e16faf093ec63778389">&#9670;&#160;</a></span>GetBufferAsUInt64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t * itk::simple::Image::GetBufferAsUInt64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ac2a79f8ee1d6d1c118baeab9708f80e1" name="ac2a79f8ee1d6d1c118baeab9708f80e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a79f8ee1d6d1c118baeab9708f80e1">&#9670;&#160;</a></span>GetBufferAsUInt64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t * itk::simple::Image::GetBufferAsUInt64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a9b011a5e138e90d1375955ba271533a8" name="a9b011a5e138e90d1375955ba271533a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b011a5e138e90d1375955ba271533a8">&#9670;&#160;</a></span>GetBufferAsUInt8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * itk::simple::Image::GetBufferAsUInt8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="BufferImportExport_8cxx-example.html#a10">BufferImportExport.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="a2b1f0a6dc3bfd68cc3c6c400d23ef23c" name="a2b1f0a6dc3bfd68cc3c6c400d23ef23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1f0a6dc3bfd68cc3c6c400d23ef23c">&#9670;&#160;</a></span>GetBufferAsUInt8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * itk::simple::Image::GetBufferAsUInt8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a827ddb6ba0b3e4e351802ce3e65c23e1" name="a827ddb6ba0b3e4e351802ce3e65c23e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827ddb6ba0b3e4e351802ce3e65c23e1">&#9670;&#160;</a></span>GetBufferAsVoid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * itk::simple::Image::GetBufferAsVoid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aabd4b5ac2632c7dcc33b971229a51be6" name="aabd4b5ac2632c7dcc33b971229a51be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd4b5ac2632c7dcc33b971229a51be6">&#9670;&#160;</a></span>GetBufferAsVoid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * itk::simple::Image::GetBufferAsVoid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the image buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is dangerous</dd></dl>
<p>The size of the buffer is the number of components*Xsize*Ysize and then Zsize of a 3D image. The buffer should be accessed as a 1-D array. For example a 3D image buffer should be accessed: </p><div class="fragment"><div class="line">uint8_t *buffer = img-&gt;GetBufferAsUInt8();</div>
<div class="line">buffer[c + numComponents*(x+xSize*(y+ySize*z))]</div>
</div><!-- fragment --><p>The pointer to the buffer is not referenced counted. Additionally, while this image is made unique before returning the pointer, additional copying and usage may introduce unexpected aliasing of the image's buffer.</p>
<p><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Vector.html">Vector</a> and Complex pixel types are both accessed via the appropriate component type method.</p>
<p>The correct method for the current pixel type of the image must be called or else an exception will be generated. For vector pixel types the type of the component of the vector must be called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a0e9d6f84e457f7f6e59665c26a02cd4e" name="a0e9d6f84e457f7f6e59665c26a02cd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9d6f84e457f7f6e59665c26a02cd4e">&#9670;&#160;</a></span>GetDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetDepth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of pixels the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is in the third dimension or 0 if the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is only 2D </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cs-example.html#a10">DicomSeriesFromArray/DicomSeriesFromArray.cs</a>, and <a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cxx-example.html#a10">DicomSeriesFromArray/DicomSeriesFromArray.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="a43163c72ca1a49abf615b3dc71e01a36" name="a43163c72ca1a49abf615b3dc71e01a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43163c72ca1a49abf615b3dc71e01a36">&#9670;&#160;</a></span>GetDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetDimension </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of physical dimensions.</p>
<p>Only the spatial dimensions are considered here. These are the dimensions the origin, spacing and direction cosine matrix are applicable to. This does not include the pixels' vector index as a dimension. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ITKIntegration_2ITKIntegration_8cxx-example.html#a7">ITKIntegration/ITKIntegration.cxx</a>, <a class="el" href="ImageRegistrationMethod1_2ImageRegistrationMethod1_8cs-example.html#a14">ImageRegistrationMethod1/ImageRegistrationMethod1.cs</a>, <a class="el" href="ImageRegistrationMethod1_2ImageRegistrationMethod1_8cxx-example.html#a9">ImageRegistrationMethod1/ImageRegistrationMethod1.cxx</a>, <a class="el" href="ImageRegistrationMethod2_2ImageRegistrationMethod2_8cs-example.html#a14">ImageRegistrationMethod2/ImageRegistrationMethod2.cs</a>, <a class="el" href="ImageRegistrationMethod2_2ImageRegistrationMethod2_8cxx-example.html#a11">ImageRegistrationMethod2/ImageRegistrationMethod2.cxx</a>, <a class="el" href="ImageRegistrationMethodBSpline1_2ImageRegistrationMethodBSpline1_8cxx-example.html#a5">ImageRegistrationMethodBSpline1/ImageRegistrationMethodBSpline1.cxx</a>, <a class="el" href="ImageRegistrationMethodBSpline3_2ImageRegistrationMethodBSpline3_8cxx-example.html#a6">ImageRegistrationMethodBSpline3/ImageRegistrationMethodBSpline3.cxx</a>, <a class="el" href="ImageRegistrationMethodDisplacement1_2ImageRegistrationMethodDisplacement1_8cxx-example.html#a8">ImageRegistrationMethodDisplacement1/ImageRegistrationMethodDisplacement1.cxx</a>, <a class="el" href="N4BiasFieldCorrection_2N4BiasFieldCorrection_8cs-example.html#a1">N4BiasFieldCorrection/N4BiasFieldCorrection.cs</a>, <a class="el" href="N4BiasFieldCorrection_2N4BiasFieldCorrection_8cxx-example.html#a3">N4BiasFieldCorrection/N4BiasFieldCorrection.cxx</a>, and <a class="el" href="SliceBySliceDecorator_2SliceBySliceDecorator_8cxx-example.html#a2">SliceBySliceDecorator/SliceBySliceDecorator.cxx</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="sitkProcessObject_8h_source.html#l00387">itk::simple::ProcessObject::CastImageToITK()</a>.</p>

</div>
</div>
<a id="a7bd35f108a2df5c966285405af409548" name="a7bd35f108a2df5c966285405af409548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd35f108a2df5c966285405af409548">&#9670;&#160;</a></span>GetDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::GetDirection </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Get the Direction. </p>
<p>Internally, the Direction is represented by a matrix 2x2 for a 2D and 3x3 for a 3D image. The matrix is passed as a 1D array in row-major form. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cs-example.html#a9">DicomSeriesFromArray/DicomSeriesFromArray.cs</a>, and <a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cxx-example.html#a9">DicomSeriesFromArray/DicomSeriesFromArray.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="a88a9572d84ae73623652bdc1ecb7cf2d" name="a88a9572d84ae73623652bdc1ecb7cf2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a9572d84ae73623652bdc1ecb7cf2d">&#9670;&#160;</a></span>GetHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetHeight </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of pixels the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is in the second dimension </p>

</div>
</div>
<a id="a600c5cd0fe2345b2d0a2e09997dfa1d6" name="a600c5cd0fe2345b2d0a2e09997dfa1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600c5cd0fe2345b2d0a2e09997dfa1d6">&#9670;&#160;</a></span>GetITKBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> * itk::simple::Image::GetITKBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get access to internal ITK data object.</p>
<p>The return value should immediately be assigned to as <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1SmartPointer.html">itk::SmartPointer</a>.</p>
<p>In many cases the value may need to be dynamically casted to the actual image type. The <a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">GetPixelIDValue()</a> method should return an PixelID which identifies the image type which the <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">DataObject</a> points to.</p>
<p>If this object has been moved, then nullptr is returned. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ITKIntegration_2ITKIntegration_8cxx-example.html#a11">ITKIntegration/ITKIntegration.cxx</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="sitkProcessObject_8h_source.html#l00387">itk::simple::ProcessObject::CastImageToITK()</a>.</p>

</div>
</div>
<a id="a590b6dd151816ef8a4b549e95ed1bf57" name="a590b6dd151816ef8a4b549e95ed1bf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590b6dd151816ef8a4b549e95ed1bf57">&#9670;&#160;</a></span>GetITKBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> * itk::simple::Image::GetITKBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get access to internal ITK data object.</p>
<p>The return value should immediately be assigned to as <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1SmartPointer.html">itk::SmartPointer</a>.</p>
<p>In many cases the value may need to be dynamically casted to the actual image type. The <a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">GetPixelIDValue()</a> method should return an PixelID which identifies the image type which the <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">DataObject</a> points to.</p>
<p>If this object has been moved, then nullptr is returned. </p>

</div>
</div>
<a id="a43df17945f303feb16b4accf1b684515" name="a43df17945f303feb16b4accf1b684515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43df17945f303feb16b4accf1b684515">&#9670;&#160;</a></span>GetMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string itk::simple::Image::GetMetaData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a meta-data dictionary entry as a string. </p>
<p>If the key is not in the dictionary then an exception is thrown.</p>
<p>string types in the dictionary are returned as their native strings. Other types are printed to string before returning. </p>

</div>
</div>
<a id="a4cf9bbdb75a90784da8012286a8692eb" name="a4cf9bbdb75a90784da8012286a8692eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf9bbdb75a90784da8012286a8692eb">&#9670;&#160;</a></span>GetMetaDataKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; itk::simple::Image::GetMetaDataKeys </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a vector of keys in from the meta-data dictionary </p>
<p>Returns a vector of keys to the key/value entries in the image's meta-data dictionary. Iterate through with these keys to get the values. </p>

</div>
</div>
<a id="abb8b4188222fc781607ab26c69fc5423" name="abb8b4188222fc781607ab26c69fc5423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b4188222fc781607ab26c69fc5423">&#9670;&#160;</a></span>GetNumberOfComponentsPerPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetNumberOfComponentsPerPixel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of components for each pixel. </p>
<p>For images with scalar or complex pixel types this method returns one. For images with a vector pixel type the method returns the number of vector components per pixel. </p>

</div>
</div>
<a id="a584912065b5cc03923319b15bd9fc16e" name="a584912065b5cc03923319b15bd9fc16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584912065b5cc03923319b15bd9fc16e">&#9670;&#160;</a></span>GetNumberOfPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t itk::simple::Image::GetNumberOfPixels </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of pixels in the image. </p>
<p>To calculate the total number of values stored continuously for the image's buffer, the NumberOfPixels should be multiplied by NumberOfComponentsPerPixel in order to account for multiple component images. </p>

</div>
</div>
<a id="a622920d3325ee831eba2ddad89d7eb3d" name="a622920d3325ee831eba2ddad89d7eb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622920d3325ee831eba2ddad89d7eb3d">&#9670;&#160;</a></span>GetOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::GetOrigin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get/Set the Origin in physical space </p>

</div>
</div>
<a id="adb89bcefd90119d4b55407be5b30cc25" name="adb89bcefd90119d4b55407be5b30cc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb89bcefd90119d4b55407be5b30cc25">&#9670;&#160;</a></span>GetPixelAsComplexFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; float &gt; itk::simple::Image::GetPixelAsComplexFloat32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1889da3071e6aa7daaa673db7be89266" name="a1889da3071e6aa7daaa673db7be89266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1889da3071e6aa7daaa673db7be89266">&#9670;&#160;</a></span>GetPixelAsComplexFloat64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; itk::simple::Image::GetPixelAsComplexFloat64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a958fc359792de9213e87dc20f8fa400d" name="a958fc359792de9213e87dc20f8fa400d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958fc359792de9213e87dc20f8fa400d">&#9670;&#160;</a></span>GetPixelAsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double itk::simple::Image::GetPixelAsDouble </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a6e04ac6dc1e3a789f6b5f3fde6a704ad" name="a6e04ac6dc1e3a789f6b5f3fde6a704ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e04ac6dc1e3a789f6b5f3fde6a704ad">&#9670;&#160;</a></span>GetPixelAsFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float itk::simple::Image::GetPixelAsFloat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ab36e43923c39880321b04eda1436c4e2" name="ab36e43923c39880321b04eda1436c4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36e43923c39880321b04eda1436c4e2">&#9670;&#160;</a></span>GetPixelAsInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t itk::simple::Image::GetPixelAsInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="abd014ee850c3b779b242577c795d568d" name="abd014ee850c3b779b242577c795d568d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd014ee850c3b779b242577c795d568d">&#9670;&#160;</a></span>GetPixelAsInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t itk::simple::Image::GetPixelAsInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ae1955c632dd4c04be1573d4dbadfcdec" name="ae1955c632dd4c04be1573d4dbadfcdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1955c632dd4c04be1573d4dbadfcdec">&#9670;&#160;</a></span>GetPixelAsInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t itk::simple::Image::GetPixelAsInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ad0c57fd2e652cef42678df6721ee91ef" name="ad0c57fd2e652cef42678df6721ee91ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c57fd2e652cef42678df6721ee91ef">&#9670;&#160;</a></span>GetPixelAsInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t itk::simple::Image::GetPixelAsInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a7bda2c933c0fc074041619f292d53b3f" name="a7bda2c933c0fc074041619f292d53b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bda2c933c0fc074041619f292d53b3f">&#9670;&#160;</a></span>GetPixelAsUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t itk::simple::Image::GetPixelAsUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a54e68cff0ddbee6c0516d2f5436df4d3" name="a54e68cff0ddbee6c0516d2f5436df4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e68cff0ddbee6c0516d2f5436df4d3">&#9670;&#160;</a></span>GetPixelAsUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t itk::simple::Image::GetPixelAsUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aeef2dd54b1b62e61e92026b92a8e8dfa" name="aeef2dd54b1b62e61e92026b92a8e8dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef2dd54b1b62e61e92026b92a8e8dfa">&#9670;&#160;</a></span>GetPixelAsUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t itk::simple::Image::GetPixelAsUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a9c1e93337f99f36e695921bb1e699126" name="a9c1e93337f99f36e695921bb1e699126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1e93337f99f36e695921bb1e699126">&#9670;&#160;</a></span>GetPixelAsUInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t itk::simple::Image::GetPixelAsUInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a26348f6e3a42a837a455d611de8485e1" name="a26348f6e3a42a837a455d611de8485e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26348f6e3a42a837a455d611de8485e1">&#9670;&#160;</a></span>GetPixelAsVectorFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; itk::simple::Image::GetPixelAsVectorFloat32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aab7c9ed9277ffd2690aecc000e974c07" name="aab7c9ed9277ffd2690aecc000e974c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7c9ed9277ffd2690aecc000e974c07">&#9670;&#160;</a></span>GetPixelAsVectorFloat64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::GetPixelAsVectorFloat64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a115dd3ac39fe400bc5015a6f04231061" name="a115dd3ac39fe400bc5015a6f04231061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115dd3ac39fe400bc5015a6f04231061">&#9670;&#160;</a></span>GetPixelAsVectorInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int16_t &gt; itk::simple::Image::GetPixelAsVectorInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a6eaf8347c90dcd454e2f2d87c3b9078c" name="a6eaf8347c90dcd454e2f2d87c3b9078c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaf8347c90dcd454e2f2d87c3b9078c">&#9670;&#160;</a></span>GetPixelAsVectorInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int32_t &gt; itk::simple::Image::GetPixelAsVectorInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a0ecd82663427b6ee5736ebc1dfedf51b" name="a0ecd82663427b6ee5736ebc1dfedf51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecd82663427b6ee5736ebc1dfedf51b">&#9670;&#160;</a></span>GetPixelAsVectorInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int64_t &gt; itk::simple::Image::GetPixelAsVectorInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a8da3f19798a0c30488ab412e3d707505" name="a8da3f19798a0c30488ab412e3d707505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da3f19798a0c30488ab412e3d707505">&#9670;&#160;</a></span>GetPixelAsVectorInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int8_t &gt; itk::simple::Image::GetPixelAsVectorInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ae280918c7fa7fa0f517442d82a1ca631" name="ae280918c7fa7fa0f517442d82a1ca631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae280918c7fa7fa0f517442d82a1ca631">&#9670;&#160;</a></span>GetPixelAsVectorUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint16_t &gt; itk::simple::Image::GetPixelAsVectorUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aacc761996e1b65903d7f003824da793f" name="aacc761996e1b65903d7f003824da793f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc761996e1b65903d7f003824da793f">&#9670;&#160;</a></span>GetPixelAsVectorUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint32_t &gt; itk::simple::Image::GetPixelAsVectorUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="affa93e9578bcf1f93e6e4d0c9b85949e" name="affa93e9578bcf1f93e6e4d0c9b85949e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa93e9578bcf1f93e6e4d0c9b85949e">&#9670;&#160;</a></span>GetPixelAsVectorUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; itk::simple::Image::GetPixelAsVectorUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="acdd696c8b0f218ea75c97c86db5983d2" name="acdd696c8b0f218ea75c97c86db5983d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd696c8b0f218ea75c97c86db5983d2">&#9670;&#160;</a></span>GetPixelAsVectorUInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; itk::simple::Image::GetPixelAsVectorUInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a pixel. </p>
<p>Returns the value of a pixel for the given index. The index follows standard SimpleITK conventions for it's length. The correct method must be called for the underlying <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a780923bec6a71b14be35d81069f343f6" name="a780923bec6a71b14be35d81069f343f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780923bec6a71b14be35d81069f343f6">&#9670;&#160;</a></span>GetPixelID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceitk_1_1simple.html#ae40bd64640f4014fba1a8a872ab4df98">PixelIDValueEnum</a> itk::simple::Image::GetPixelID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pixel type</p>
<p>The pixel type is set at construction type and can not be manually changed, unless by assignment. The value may be -1 or "Unknown". </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="BufferImportExport_8cxx-example.html#a9">BufferImportExport.cxx</a>, <a class="el" href="DemonsRegistration2_2DemonsRegistration2_8cxx-example.html#a6">DemonsRegistration2/DemonsRegistration2.cxx</a>, <a class="el" href="FilterProgressReporting_2FilterProgressReporting_8cxx-example.html#a13">FilterProgressReporting/FilterProgressReporting.cxx</a>, <a class="el" href="SimpleGaussian_2SimpleGaussian_8cs-example.html#a9">SimpleGaussian/SimpleGaussian.cs</a>, <a class="el" href="SimpleGaussian_2SimpleGaussian_8cxx-example.html#a9">SimpleGaussian/SimpleGaussian.cxx</a>, and <a class="el" href="SimpleGaussianFunctional_8cxx-example.html#a2">SimpleGaussianFunctional.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="ad195963d0b257560819b833b9cfe18d6" name="ad195963d0b257560819b833b9cfe18d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad195963d0b257560819b833b9cfe18d6">&#9670;&#160;</a></span>GetPixelIDTypeAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string itk::simple::Image::GetPixelIDTypeAsString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the pixel type as a human readable string value. </p>

<p class="reference">Referenced by <a class="el" href="sitkProcessObject_8h_source.html#l00387">itk::simple::ProcessObject::CastImageToITK()</a>.</p>

</div>
</div>
<a id="a3c27e845c3327ae8cf133db1750fd18b" name="a3c27e845c3327ae8cf133db1750fd18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c27e845c3327ae8cf133db1750fd18b">&#9670;&#160;</a></span>GetPixelIDValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceitk_1_1simple.html#aaf027344ec3011c3ac6fcfd77271bb75">PixelIDValueType</a> itk::simple::Image::GetPixelIDValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade45738b2c906a51f23532aa972f6169" name="ade45738b2c906a51f23532aa972f6169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade45738b2c906a51f23532aa972f6169">&#9670;&#160;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; itk::simple::Image::GetSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of pixels the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is in each dimension as a std::vector. The size of the vector is equal to the number of dimensions for the image. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DicomConvert_2DicomConvert_8cxx-example.html#a4">DicomConvert/DicomConvert.cxx</a>, <a class="el" href="DicomSeriesReader_2DicomSeriesReader_8cs-example.html#a5">DicomSeriesReader/DicomSeriesReader.cs</a>, <a class="el" href="DicomSeriesReader_2DicomSeriesReader_8cxx-example.html#a5">DicomSeriesReader/DicomSeriesReader.cxx</a>, <a class="el" href="ImageIOSelection_2ImageIOSelection_8cs-example.html#a7">ImageIOSelection/ImageIOSelection.cs</a>, <a class="el" href="ImageIOSelection_2ImageIOSelection_8cxx-example.html#a7">ImageIOSelection/ImageIOSelection.cxx</a>, <a class="el" href="ImageRegistrationMethodDisplacement1_2ImageRegistrationMethodDisplacement1_8cxx-example.html#a24">ImageRegistrationMethodDisplacement1/ImageRegistrationMethodDisplacement1.cxx</a>, and <a class="el" href="SliceBySliceDecorator_2SliceBySliceDecorator_8cxx-example.html#a1">SliceBySliceDecorator/SliceBySliceDecorator.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="af4705e6e3ad0dcec4a8230462af81c19" name="af4705e6e3ad0dcec4a8230462af81c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4705e6e3ad0dcec4a8230462af81c19">&#9670;&#160;</a></span>GetSizeOfPixelComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetSizeOfPixelComponent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes per component of a pixel. </p>
<p>Returns the <code>sizeof</code> the pixel component type. </p>

</div>
</div>
<a id="a669907e56274c6ca2838be3bf4a5ac9f" name="a669907e56274c6ca2838be3bf4a5ac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669907e56274c6ca2838be3bf4a5ac9f">&#9670;&#160;</a></span>GetSpacing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::GetSpacing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get/Set the Spacing of the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> as an std::vector .</p>
<p>The spacing describes the physical size of each pixel. The length of the vector is equal to the dimension of the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cs-example.html#a17">DicomSeriesFromArray/DicomSeriesFromArray.cs</a>, and <a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cxx-example.html#a17">DicomSeriesFromArray/DicomSeriesFromArray.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="af7b9ca4a6cd1a0c77e8c5c713e447b3a" name="af7b9ca4a6cd1a0c77e8c5c713e447b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b9ca4a6cd1a0c77e8c5c713e447b3a">&#9670;&#160;</a></span>GetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::simple::Image::GetWidth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of pixels the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> is in the first dimension </p>

</div>
</div>
<a id="a38b869a842f2e7aeb75fbd0a84046cca" name="a38b869a842f2e7aeb75fbd0a84046cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b869a842f2e7aeb75fbd0a84046cca">&#9670;&#160;</a></span>HasMetaDataKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::simple::Image::HasMetaDataKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the meta-data dictionary for the existence of a key. </p>

</div>
</div>
<a id="a8b1318ae056ca7ccda06025b2c775db4" name="a8b1318ae056ca7ccda06025b2c775db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1318ae056ca7ccda06025b2c775db4">&#9670;&#160;</a></span>InternalInitialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::InternalInitialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceitk_1_1simple.html#aaf027344ec3011c3ac6fcfd77271bb75">PixelIDValueType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1DataObject.html">itk::DataObject</a> *</td>          <td class="paramname"><span class="paramname"><em>image</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method called by certain constructors to convert ITK images into SimpleITK ones.</p>
<p>This is the single method which needs to be explicitly instantiated to separate the internal ITK and Pimple image from the external SimpleITK interface. Template parameters have been chosen carefully to flexibly enable this. </p>

<p class="reference">Referenced by <a class="el" href="sitkImage_8h_source.html#l00170">Image()</a>.</p>

</div>
</div>
<a id="a69467355f435bc8ec5749402679ce0b1" name="a69467355f435bc8ec5749402679ce0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69467355f435bc8ec5749402679ce0b1">&#9670;&#160;</a></span>IsCongruentImageGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::simple::Image::IsCongruentImageGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>otherImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>coordinateTolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>directionTolerance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the images' pixels at the same index occupy the same physical space.</p>
<p>Compares the origin, spacing, and direction for equality within provided tolerances. There is no check for matching regions in between the images.</p>
<p>If The dimensions of the images do not match, false is returned. </p>

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="a5422fe56eb946fc813b85d134a36da13" name="a5422fe56eb946fc813b85d134a36da13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5422fe56eb946fc813b85d134a36da13">&#9670;&#160;</a></span>IsSameImageGeometryAs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::simple::Image::IsSameImageGeometryAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>otherImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a62caf35a0504c5c761abdf71d4018a89">DefaultImageCoordinateTolerance</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa0f5123f49cd495f86349f7e06a49c3d">DefaultImageDirectionTolerance</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the images have the same grid in physical space.</p>
<p>Compares largest possible regions for equality, and the origin, spacing, and direction cosines for equality within provided tolerances.</p>
<p>If the dimensions of the images do not match, false is returned. </p>

<p class="reference">References <a class="el" href="sitkImage_8h_source.html#l00694">DefaultImageCoordinateTolerance</a>, <a class="el" href="sitkImage_8h_source.html#l00695">DefaultImageDirectionTolerance</a>, and <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="aec5b1f66e3812a286b3e9f4ac8ed976f" name="aec5b1f66e3812a286b3e9f4ac8ed976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5b1f66e3812a286b3e9f4ac8ed976f">&#9670;&#160;</a></span>IsUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::simple::Image::IsUnique </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if no other SimpleITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> object refers to the same internal data structure. </p>

</div>
</div>
<a id="ab5066b75d324db414df1a34c4065d1c9" name="ab5066b75d324db414df1a34c4065d1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5066b75d324db414df1a34c4065d1c9">&#9670;&#160;</a></span>MakeUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::MakeUnique </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs actually coping if needed to make object unique. </p>
<p>The <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> class by default performs lazy coping and assignment. This method make sure that coping actually happens to the <a class="elRef" href="https://www.itk.org/Doxygen/html/classitk_1_1Image.html">itk::Image</a> pointed to is only pointed to by this object. </p>

</div>
</div>
<a id="a544257ed6b37d939c081af1c18753b2c" name="a544257ed6b37d939c081af1c18753b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544257ed6b37d939c081af1c18753b2c">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp; itk::simple::Image::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="abd7c186de418cc97050e3ced622cf8c2" name="abd7c186de418cc97050e3ced622cf8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7c186de418cc97050e3ced622cf8c2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp; itk::simple::Image::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="a3f8edfcd47f578d5e6cd48b76550caf8" name="a3f8edfcd47f578d5e6cd48b76550caf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8edfcd47f578d5e6cd48b76550caf8">&#9670;&#160;</a></span>ProxyForInPlaceOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> itk::simple::Image::ProxyForInPlaceOperation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced method not commonly needed. </p>
<p>This method is designed to support implementations "in-place" object behavior for methods which operate on r-value references. The returned image is a new image which has a low level pointer to this object's image buffer, without the SimpleITK or ITK reference counting. This is implemented by setting the new ITK <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a>'s buffer to the same as this objects without ownership.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method bypasses the SimpleITK reference counting, and the reference needs to be manually maintained in the scope. The resulting object is designed only to be a temporary.</dd></dl>
<p>In the following example this method is used instead of an <code>std::move</code> call when the filter's first argument takes an r-value reference. The <code>img</code> object will container the results of the filter execution, and the <code>img</code> image buffer will be preserved in case of exceptions, and the meta-data will remain in the img object. </p><div class="fragment"><div class="line">filter.Execute( img.ProxyForInPlaceOperation() );</div>
</div><!-- fragment --><p>The meta-data dictionary is not copied to the returned proxy image. </p>

<p class="reference">Referenced by <a class="el" href="sitkImageOperators_8h_source.html#l00321">itk::simple::operator%=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00327">itk::simple::operator%=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00333">itk::simple::operator&amp;=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00339">itk::simple::operator&amp;=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00297">itk::simple::operator*=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00303">itk::simple::operator*=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00273">itk::simple::operator+=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00279">itk::simple::operator+=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00285">itk::simple::operator-=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00291">itk::simple::operator-=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00309">itk::simple::operator/=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00315">itk::simple::operator/=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00357">itk::simple::operator^=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00363">itk::simple::operator^=()</a>, <a class="el" href="sitkImageOperators_8h_source.html#l00345">itk::simple::operator|=()</a>, and <a class="el" href="sitkImageOperators_8h_source.html#l00351">itk::simple::operator|=()</a>.</p>

</div>
</div>
<a id="a04d6c8b3777b454b6da1ee1d3e7ed56f" name="a04d6c8b3777b454b6da1ee1d3e7ed56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d6c8b3777b454b6da1ee1d3e7ed56f">&#9670;&#160;</a></span>SetDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetDirection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Get the Direction. </p>
<p>Internally, the Direction is represented by a matrix 2x2 for a 2D and 3x3 for a 3D image. The matrix is passed as a 1D array in row-major form. </p>

</div>
</div>
<a id="a1663c39bf013511f30a632a6b4290d83" name="a1663c39bf013511f30a632a6b4290d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1663c39bf013511f30a632a6b4290d83">&#9670;&#160;</a></span>SetMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetMetaData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an entry in the meta-data dictionary. </p>
<p>Replaces or creates an entry in the image's meta-data dictionary. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cs-example.html#a2">DicomSeriesFromArray/DicomSeriesFromArray.cs</a>, and <a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cxx-example.html#a2">DicomSeriesFromArray/DicomSeriesFromArray.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="a9648b61b714ddd980d3b7b78bf5562ed" name="a9648b61b714ddd980d3b7b78bf5562ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9648b61b714ddd980d3b7b78bf5562ed">&#9670;&#160;</a></span>SetOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetOrigin </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>origin</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get/Set the Origin in physical space </p>

</div>
</div>
<a id="aff869ab52a6b49bfbb4caa4a8ade6209" name="aff869ab52a6b49bfbb4caa4a8ade6209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff869ab52a6b49bfbb4caa4a8ade6209">&#9670;&#160;</a></span>SetPixelAsComplexFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsComplexFloat32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="adb107c591ef00628fe9b3d3ff8b369ac" name="adb107c591ef00628fe9b3d3ff8b369ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb107c591ef00628fe9b3d3ff8b369ac">&#9670;&#160;</a></span>SetPixelAsComplexFloat64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsComplexFloat64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1ba546cc106fc7af755421fa6fe72871" name="a1ba546cc106fc7af755421fa6fe72871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba546cc106fc7af755421fa6fe72871">&#9670;&#160;</a></span>SetPixelAsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsDouble </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ae243d0aa8d3a1f0b5c8a5335d21ae2e5" name="ae243d0aa8d3a1f0b5c8a5335d21ae2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae243d0aa8d3a1f0b5c8a5335d21ae2e5">&#9670;&#160;</a></span>SetPixelAsFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsFloat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a75442c64fc1933c088c02ef11be5373a" name="a75442c64fc1933c088c02ef11be5373a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75442c64fc1933c088c02ef11be5373a">&#9670;&#160;</a></span>SetPixelAsInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a5b9214c2b5437c831eff5a5ca220439c" name="a5b9214c2b5437c831eff5a5ca220439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9214c2b5437c831eff5a5ca220439c">&#9670;&#160;</a></span>SetPixelAsInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a3f2c9ff8b97b2ffd9c8a7b106377a0f8" name="a3f2c9ff8b97b2ffd9c8a7b106377a0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2c9ff8b97b2ffd9c8a7b106377a0f8">&#9670;&#160;</a></span>SetPixelAsInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a8c01f6319e38f168010c6c597465a146" name="a8c01f6319e38f168010c6c597465a146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c01f6319e38f168010c6c597465a146">&#9670;&#160;</a></span>SetPixelAsInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a50743b5a080be742524c461a4f1aa320" name="a50743b5a080be742524c461a4f1aa320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50743b5a080be742524c461a4f1aa320">&#9670;&#160;</a></span>SetPixelAsUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a586633efa5fd70f1769a5e2255459264" name="a586633efa5fd70f1769a5e2255459264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586633efa5fd70f1769a5e2255459264">&#9670;&#160;</a></span>SetPixelAsUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a6088cb5d92145f9aec2f82b4b273dee5" name="a6088cb5d92145f9aec2f82b4b273dee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6088cb5d92145f9aec2f82b4b273dee5">&#9670;&#160;</a></span>SetPixelAsUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="abe256cff6ccbcb37f89a61a83fda0763" name="abe256cff6ccbcb37f89a61a83fda0763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe256cff6ccbcb37f89a61a83fda0763">&#9670;&#160;</a></span>SetPixelAsUInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsUInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a862c2f02ce7abc80943e1cbbb75f8954" name="a862c2f02ce7abc80943e1cbbb75f8954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862c2f02ce7abc80943e1cbbb75f8954">&#9670;&#160;</a></span>SetPixelAsVectorFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorFloat32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ae0326247d1ca5051fba7d1c07b676099" name="ae0326247d1ca5051fba7d1c07b676099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0326247d1ca5051fba7d1c07b676099">&#9670;&#160;</a></span>SetPixelAsVectorFloat64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorFloat64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a235e853836366fac8ee98de3d80fb866" name="a235e853836366fac8ee98de3d80fb866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235e853836366fac8ee98de3d80fb866">&#9670;&#160;</a></span>SetPixelAsVectorInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a8c8b8d47857d714e5c1cc06f0dc78b43" name="a8c8b8d47857d714e5c1cc06f0dc78b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8b8d47857d714e5c1cc06f0dc78b43">&#9670;&#160;</a></span>SetPixelAsVectorInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="ab595292b40ced613b36411608f1408a9" name="ab595292b40ced613b36411608f1408a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab595292b40ced613b36411608f1408a9">&#9670;&#160;</a></span>SetPixelAsVectorInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a88e10b7b03904ff90b38e9cc92ccf1ef" name="a88e10b7b03904ff90b38e9cc92ccf1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e10b7b03904ff90b38e9cc92ccf1ef">&#9670;&#160;</a></span>SetPixelAsVectorInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a7d3627592f3f167e398a3b4b43ab1d91" name="a7d3627592f3f167e398a3b4b43ab1d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3627592f3f167e398a3b4b43ab1d91">&#9670;&#160;</a></span>SetPixelAsVectorUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aeb6ae62b2ba271d90764e03ba3155f3f" name="aeb6ae62b2ba271d90764e03ba3155f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6ae62b2ba271d90764e03ba3155f3f">&#9670;&#160;</a></span>SetPixelAsVectorUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="aecc04519f671706868e9c642cf1e4dad" name="aecc04519f671706868e9c642cf1e4dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc04519f671706868e9c642cf1e4dad">&#9670;&#160;</a></span>SetPixelAsVectorUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1e53202d40fd48f6d4b9fb55f2ed9c6d" name="a1e53202d40fd48f6d4b9fb55f2ed9c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e53202d40fd48f6d4b9fb55f2ed9c6d">&#9670;&#160;</a></span>SetPixelAsVectorUInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetPixelAsVectorUInt8 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pixel. </p>
<p>Set the value of a pixel at the provided index. The index follows standard SimpleITK conventions for it's length. The correct method must be called which should match the underlying image type, otherwise an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the zero based index into the image. It's length must be at least the value of <a class="el" href="#a43163c72ca1a49abf615b3dc71e01a36">GetDimension()</a>, additional elements will be ignored. Boundary checking is performed on idx, if it is out of bounds an exception will be thrown. </td></tr>
    <tr><td class="paramname">v</td><td>value to set the pixel to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c27e845c3327ae8cf133db1750fd18b">Image::GetPixelIDValue</a> </dd></dl>

</div>
</div>
<a id="a1b285752e1a79e123c055dc6fa95a50a" name="a1b285752e1a79e123c055dc6fa95a50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b285752e1a79e123c055dc6fa95a50a">&#9670;&#160;</a></span>SetSpacing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::simple::Image::SetSpacing </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>spacing</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get/Set the Spacing of the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a> as an std::vector .</p>
<p>The spacing describes the physical size of each pixel. The length of the vector is equal to the dimension of the <a class="el" href="classitk_1_1simple_1_1Image.html" title="The Image class for SimpleITK.">Image</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cs-example.html#a7">DicomSeriesFromArray/DicomSeriesFromArray.cs</a>, and <a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cxx-example.html#a7">DicomSeriesFromArray/DicomSeriesFromArray.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="a6648c0273680255f7d75e5608fe78f74" name="a6648c0273680255f7d75e5608fe78f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6648c0273680255f7d75e5608fe78f74">&#9670;&#160;</a></span>ToScalarImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> itk::simple::Image::ToScalarImage </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inPlace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a image of vector pixel type to a scalar image with N+1 dimensions. </p>
<p>This method will convert a vector image to a scalar image with the size of the first dimension equal to the number of components. If the image is already a scalar image then the image is returned.</p>
<p>For the additional dimension the origin is set to zero, the spacing to one, and the new components of the direction cosine to the identity matrix.</p>
<p>An exception is thrown if the image is has SITK_MAX_DIMENSION dimensions or if the pixel type is a label or complex pixel type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPlace</td><td>If true then the image is made unique and converted in place updating this image, otherwise a copy of the image is made and returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad6ee03fbbfe962cd2b5b39ef9fc4df44" title="Convert the first dimension to the components for image with vector pixel type.">ToVectorImage</a> </dd></dl>

</div>
</div>
<a id="a19ef31f237592ffbff6132c13fd834c1" name="a19ef31f237592ffbff6132c13fd834c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ef31f237592ffbff6132c13fd834c1">&#9670;&#160;</a></span>ToScalarInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TImageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> itk::simple::Image::ToScalarInternal </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inPlace</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal methods for converting images between vectors and scalars. </p>

</div>
</div>
<a id="a47c9fa1902dae8f984bda1bdeafa4a3c" name="a47c9fa1902dae8f984bda1bdeafa4a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c9fa1902dae8f984bda1bdeafa4a3c">&#9670;&#160;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string itk::simple::Image::ToString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="ad6ee03fbbfe962cd2b5b39ef9fc4df44" name="ad6ee03fbbfe962cd2b5b39ef9fc4df44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ee03fbbfe962cd2b5b39ef9fc4df44">&#9670;&#160;</a></span>ToVectorImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> itk::simple::Image::ToVectorImage </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inPlace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the first dimension to the components for image with vector pixel type. </p>
<p>This method will convert a scalar image to a vector image with the number of components equal to the size of the first dimension. If the image is already a vector image then the image is returned.</p>
<p>The components of the direction cosine matrix for the first dimension must be the identity matrix, or else an exception is thrown.</p>
<p>An exception is thrown if the image is 2D or if the pixel type is a label or complex pixel type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPlace</td><td>If true then the image is made unique and converted in place updating this image, otherwise a copy of the image is made and returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6648c0273680255f7d75e5608fe78f74" title="Convert a image of vector pixel type to a scalar image with N+1 dimensions.">ToScalarImage</a> </dd></dl>

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="a871c21759c1ae4db59ec0fbce2d3fe75" name="a871c21759c1ae4db59ec0fbce2d3fe75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871c21759c1ae4db59ec0fbce2d3fe75">&#9670;&#160;</a></span>ToVectorInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TImageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1simple_1_1Image.html">Image</a> itk::simple::Image::ToVectorInternal </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inPlace</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal methods for converting images between vectors and scalars. </p>

<p class="reference">References <a class="el" href="#a42a8055958ef17e5fd3602e68e28fcc7">Image()</a>.</p>

</div>
</div>
<a id="a639da24d8df6d41989447d2ec95cb51d" name="a639da24d8df6d41989447d2ec95cb51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639da24d8df6d41989447d2ec95cb51d">&#9670;&#160;</a></span>TransformContinuousIndexToPhysicalPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::TransformContinuousIndexToPhysicalPoint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classitk_1_1simple_1_1Transform.html" title="A simplified wrapper around a variety of ITK transforms.">Transform</a> continuous index to physical point </p>

</div>
</div>
<a id="a87c1a1ecaa5bd379d3132c7e95619aaa" name="a87c1a1ecaa5bd379d3132c7e95619aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c1a1ecaa5bd379d3132c7e95619aaa">&#9670;&#160;</a></span>TransformIndexToPhysicalPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::TransformIndexToPhysicalPoint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classitk_1_1simple_1_1Transform.html" title="A simplified wrapper around a variety of ITK transforms.">Transform</a> index to physical point </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cs-example.html#a3">DicomSeriesFromArray/DicomSeriesFromArray.cs</a>, and <a class="el" href="DicomSeriesFromArray_2DicomSeriesFromArray_8cxx-example.html#a3">DicomSeriesFromArray/DicomSeriesFromArray.cxx</a>.</dd>
</dl>

</div>
</div>
<a id="af2aa3f19b31f54ec9fc2846a29428adb" name="af2aa3f19b31f54ec9fc2846a29428adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2aa3f19b31f54ec9fc2846a29428adb">&#9670;&#160;</a></span>TransformPhysicalPointToContinuousIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; itk::simple::Image::TransformPhysicalPointToContinuousIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classitk_1_1simple_1_1Transform.html" title="A simplified wrapper around a variety of ITK transforms.">Transform</a> physical point to continuous index </p>

</div>
</div>
<a id="a9474e4ded374c8350418fe5329187704" name="a9474e4ded374c8350418fe5329187704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9474e4ded374c8350418fe5329187704">&#9670;&#160;</a></span>TransformPhysicalPointToIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int64_t &gt; itk::simple::Image::TransformPhysicalPointToIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classitk_1_1simple_1_1Transform.html" title="A simplified wrapper around a variety of ITK transforms.">Transform</a> physical point to index </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aaf84f462b2cb8fd9088d79765360285a" name="aaf84f462b2cb8fd9088d79765360285a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf84f462b2cb8fd9088d79765360285a">&#9670;&#160;</a></span>AllocateMemberFunctionAddressor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct AllocateMemberFunctionAddressor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00752">752</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">References <a class="el" href="sitkImage_8h_source.html#l00752">AllocateMemberFunctionAddressor</a>.</p>

<p class="reference">Referenced by <a class="el" href="sitkImage_8h_source.html#l00752">AllocateMemberFunctionAddressor</a>.</p>

</div>
</div>
<a id="aa9abddb4e526202df2e9408f7437d250" name="aa9abddb4e526202df2e9408f7437d250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9abddb4e526202df2e9408f7437d250">&#9670;&#160;</a></span>DispatchedInternalInitialiationAddressor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct DispatchedInternalInitialiationAddressor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00751">751</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">References <a class="el" href="sitkImage_8h_source.html#l00751">DispatchedInternalInitialiationAddressor</a>.</p>

<p class="reference">Referenced by <a class="el" href="sitkImage_8h_source.html#l00751">DispatchedInternalInitialiationAddressor</a>.</p>

</div>
</div>
<a id="a9de5bb1d9d0940a24c82985d120d403e" name="a9de5bb1d9d0940a24c82985d120d403e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de5bb1d9d0940a24c82985d120d403e">&#9670;&#160;</a></span>ToScalarAddressor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ToScalarAddressor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00754">754</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">References <a class="el" href="sitkImage_8h_source.html#l00754">ToScalarAddressor</a>.</p>

<p class="reference">Referenced by <a class="el" href="sitkImage_8h_source.html#l00754">ToScalarAddressor</a>.</p>

</div>
</div>
<a id="a5a3f2c20fd85558f113d50dd7e8c385a" name="a5a3f2c20fd85558f113d50dd7e8c385a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3f2c20fd85558f113d50dd7e8c385a">&#9670;&#160;</a></span>ToVectorAddressor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ToVectorAddressor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00753">753</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">References <a class="el" href="sitkImage_8h_source.html#l00753">ToVectorAddressor</a>.</p>

<p class="reference">Referenced by <a class="el" href="sitkImage_8h_source.html#l00753">ToVectorAddressor</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a62caf35a0504c5c761abdf71d4018a89" name="a62caf35a0504c5c761abdf71d4018a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62caf35a0504c5c761abdf71d4018a89">&#9670;&#160;</a></span>DefaultImageCoordinateTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double itk::simple::Image::DefaultImageCoordinateTolerance = 1e-6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00694">694</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a5422fe56eb946fc813b85d134a36da13">IsSameImageGeometryAs()</a>.</p>

</div>
</div>
<a id="aa0f5123f49cd495f86349f7e06a49c3d" name="aa0f5123f49cd495f86349f7e06a49c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f5123f49cd495f86349f7e06a49c3d">&#9670;&#160;</a></span>DefaultImageDirectionTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double itk::simple::Image::DefaultImageDirectionTolerance = 1e-6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00695">695</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a5422fe56eb946fc813b85d134a36da13">IsSameImageGeometryAs()</a>.</p>

</div>
</div>
<a id="a58d8e24a3e9421653f5550a3d191ee58" name="a58d8e24a3e9421653f5550a3d191ee58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d8e24a3e9421653f5550a3d191ee58">&#9670;&#160;</a></span>m_PimpleImage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classitk_1_1simple_1_1PimpleImageBase.html">PimpleImageBase</a>&gt; itk::simple::Image::m_PimpleImage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sitkImage_8h_source.html#l00757">757</a> of file <a class="el" href="sitkImage_8h_source.html">sitkImage.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="sitkImage_8h_source.html">sitkImage.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
    Generated on <span id="datetime">unknown</span> for SimpleITK by &#160;
    <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.13.2 | <a href="https://simpleitk.org/privacy_policy.html">
      Privacy Policy</a>
</small></address>
</body>
</html>
